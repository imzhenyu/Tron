/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Microsoft Corporation
 * 
 * -=- Robust Distributed System Nucleus (rDSN) -=- 
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Description:
 *     What is this file about?
 *
 * Revision history:
 *     Feb., 2016, @imzhenyu (Zhenyu Guo), done in Tron project and copied here
 *     xxxx-xx-xx, author, fix bug about xxx
 */
 




//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.retail.not
//     Template : Microsoft.Bond.Rules.dll#Rules_Bond_CSharp.tt
//     File     : contract_types.cs
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::Microsoft.Bond;
using global::System;
using global::System.Collections;
using global::System.Collections.Generic;
using global::System.Text;

namespace rDSN
{
namespace Tron
{

/// <summary>
/// ServiceMethod
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceMethod : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Name
    private String m_Name;

    // 2: Optional string InputTypeFullName
    private String m_InputTypeFullName;

    // 3: Optional string OutputTypeFullName
    private String m_OutputTypeFullName;

    // 4: Optional string ParameterName
    private String m_ParameterName;

    /// <summary>
    /// Name
    /// </summary>
    public String Name
    {
        get { return this.m_Name; }
        set { this.m_Name = value; }
    }

    /// <summary>
    /// InputTypeFullName
    /// </summary>
    public String InputTypeFullName
    {
        get { return this.m_InputTypeFullName; }
        set { this.m_InputTypeFullName = value; }
    }

    /// <summary>
    /// OutputTypeFullName
    /// </summary>
    public String OutputTypeFullName
    {
        get { return this.m_OutputTypeFullName; }
        set { this.m_OutputTypeFullName = value; }
    }

    /// <summary>
    /// ParameterName
    /// </summary>
    public String ParameterName
    {
        get { return this.m_ParameterName; }
        set { this.m_ParameterName = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Name_meta = new Metadata();
        public static readonly Metadata InputTypeFullName_meta = new Metadata();
        public static readonly Metadata OutputTypeFullName_meta = new Metadata();
        public static readonly Metadata ParameterName_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceMethod");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Name
            Name_meta.name = "Name";
            Name_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // InputTypeFullName
            InputTypeFullName_meta.name = "InputTypeFullName";
            InputTypeFullName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // OutputTypeFullName
            OutputTypeFullName_meta.name = "OutputTypeFullName";
            OutputTypeFullName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // ParameterName
            ParameterName_meta.name = "ParameterName";
            ParameterName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Name = 1;
        public const int InputTypeFullName = 2;
        public const int OutputTypeFullName = 3;
        public const int ParameterName = 4;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Name = "Name";
        public const String s_InputTypeFullName = "InputTypeFullName";
        public const String s_OutputTypeFullName = "OutputTypeFullName";
        public const String s_ParameterName = "ParameterName";
    }   // ~__internal

    // Constructor
    public ServiceMethod()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Name = string.Empty;
        m_InputTypeFullName = string.Empty;
        m_OutputTypeFullName = string.Empty;
        m_ParameterName = string.Empty;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceMethod cloned = new global::rDSN.Tron.ServiceMethod();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceMethod that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Name
        that.Name = this.Name;
        // 2: string InputTypeFullName
        that.InputTypeFullName = this.InputTypeFullName;
        // 3: string OutputTypeFullName
        that.OutputTypeFullName = this.OutputTypeFullName;
        // 4: string ParameterName
        that.ParameterName = this.ParameterName;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Name = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.InputTypeFullName = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.OutputTypeFullName = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ParameterName = reader.ReadString();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Name:  // id=1
                    this.Name = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.InputTypeFullName:  // id=2
                    this.InputTypeFullName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.OutputTypeFullName:  // id=3
                    this.OutputTypeFullName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.ParameterName:  // id=4
                    this.ParameterName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceMethod))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Name_meta.default_value.Equals(m_Name)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
                writer.WriteString(m_Name);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
        }

        if (writeAllFields || (!Schema.InputTypeFullName_meta.default_value.Equals(m_InputTypeFullName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.InputTypeFullName, Schema.InputTypeFullName_meta);
                writer.WriteString(m_InputTypeFullName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.InputTypeFullName, Schema.InputTypeFullName_meta);
        }

        if (writeAllFields || (!Schema.OutputTypeFullName_meta.default_value.Equals(m_OutputTypeFullName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.OutputTypeFullName, Schema.OutputTypeFullName_meta);
                writer.WriteString(m_OutputTypeFullName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.OutputTypeFullName, Schema.OutputTypeFullName_meta);
        }

        if (writeAllFields || (!Schema.ParameterName_meta.default_value.Equals(m_ParameterName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.ParameterName, Schema.ParameterName_meta);
                writer.WriteString(m_ParameterName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.ParameterName, Schema.ParameterName_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Name";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="InputTypeFullName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="OutputTypeFullName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="ParameterName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceMethod that = obj as ServiceMethod;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceMethod other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceMethod that)
    {
        bool equals = true;
        
        equals = equals && ((this.Name == null) == (that.Name == null));
        equals = equals && (this.Name == null ? true : (this.Name.Length == that.Name.Length));
        equals = equals && ((this.InputTypeFullName == null) == (that.InputTypeFullName == null));
        equals = equals && (this.InputTypeFullName == null ? true : (this.InputTypeFullName.Length == that.InputTypeFullName.Length));
        equals = equals && ((this.OutputTypeFullName == null) == (that.OutputTypeFullName == null));
        equals = equals && (this.OutputTypeFullName == null ? true : (this.OutputTypeFullName.Length == that.OutputTypeFullName.Length));
        equals = equals && ((this.ParameterName == null) == (that.ParameterName == null));
        equals = equals && (this.ParameterName == null ? true : (this.ParameterName.Length == that.ParameterName.Length));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceMethod that)
    {
        bool equals = true;
        
        equals = equals && (this.Name == null ? true : this.Name == that.Name);
        equals = equals && (this.InputTypeFullName == null ? true : this.InputTypeFullName == that.InputTypeFullName);
        equals = equals && (this.OutputTypeFullName == null ? true : this.OutputTypeFullName == that.OutputTypeFullName);
        equals = equals && (this.ParameterName == null ? true : this.ParameterName == that.ParameterName);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Name, this.Name, separator);
        sb.AppendFormat(format, __internal.s_InputTypeFullName, this.InputTypeFullName, separator);
        sb.AppendFormat(format, __internal.s_OutputTypeFullName, this.OutputTypeFullName, separator);
        sb.AppendFormat(format, __internal.s_ParameterName, this.ParameterName, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServiceMethod

/// <summary>
/// ServiceAPI
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceAPI : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Name
    private String m_Name;

    // 2: Optional map<string, rDSN.Tron.ServiceMethod> Methods
    private Dictionary<String, global::rDSN.Tron.ServiceMethod> m_Methods;

    /// <summary>
    /// Name
    /// </summary>
    public String Name
    {
        get { return this.m_Name; }
        set { this.m_Name = value; }
    }

    /// <summary>
    /// Methods
    /// </summary>
    public Dictionary<String, global::rDSN.Tron.ServiceMethod> Methods
    {
        get { return this.m_Methods; }
        set { this.m_Methods = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Name_meta = new Metadata();
        public static readonly Metadata Methods_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceAPI");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Name
            Name_meta.name = "Name";
            Name_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Methods
            Methods_meta.name = "Methods";
            Methods_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Name = 1;
        public const int Methods = 2;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Name = "Name";
        public const String s_Methods = "Methods";
    }   // ~__internal

    // Constructor
    public ServiceAPI()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Name = string.Empty;
        if (m_Methods == null)
        {
            m_Methods = new Dictionary<String, global::rDSN.Tron.ServiceMethod>();
        }
        else
        {
            m_Methods.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceAPI cloned = new global::rDSN.Tron.ServiceAPI();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceAPI that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Name
        that.Name = this.Name;
        // 2: map<string, rDSN.Tron.ServiceMethod> Methods
        if (this.Methods != null)
        {
            if (that.Methods == null)
            {
                that.Methods = new Dictionary<String, global::rDSN.Tron.ServiceMethod>();
            }
            else
            {
                that.Methods.Clear();
            }
            foreach (var keyValPair1 in this.Methods)
            {
                String key2 = default(String);
                global::rDSN.Tron.ServiceMethod val3 = default(global::rDSN.Tron.ServiceMethod);
                key2 = keyValPair1.Key;
                val3 = (keyValPair1.Value == null ? null : (global::rDSN.Tron.ServiceMethod)keyValPair1.Value.Clone());
                that.Methods[key2] = val3;
            }
        }
        else
        {
            that.Methods = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Name = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Methods(reader, global::Microsoft.Bond.BondDataType.BT_MAP);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Name:  // id=1
                    this.Name = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Methods:  // id=2
                    this.ReadField_impl_Methods(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Methods(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_MAP);
 
        
        BondDataType keyType1, valueType2;
    
        UInt32 count3;
    
        reader.ReadContainerBegin(out count3, out keyType1, out valueType2);
        global::Microsoft.Bond.ReadHelper.ValidateType(valueType2, global::Microsoft.Bond.BondDataType.BT_STRUCT);
    
        for (UInt32 i4 = 0; i4 < count3; i4++)
        {
            String key5 = default(String);
            global::rDSN.Tron.ServiceMethod val6 = new global::rDSN.Tron.ServiceMethod();
    
            // Read key
             
            key5 = global::Microsoft.Bond.ReadHelper.ReadString(reader, keyType1);
    
            // Read value
             
            ReadHelper.ReadStruct(reader, val6, valueType2);
            //
            this.m_Methods[key5] = val6;
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Methods


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceAPI))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Name_meta.default_value.Equals(m_Name)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
                writer.WriteString(m_Name);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
        }

        UInt32 count1 = ((UInt32)m_Methods.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_MAP, __ordinals.Methods, Schema.Methods_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRING, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            foreach (var iter2 in m_Methods)
            {
                // Key
                    writer.WriteString(iter2.Key);
                // Value
                    iter2.Value.Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_MAP, __ordinals.Methods, Schema.Methods_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Name";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Methods";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_MAP;
        field.type.key = new global::Microsoft.Bond.TypeDef();
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.key.id = global::Microsoft.Bond.BondDataType.BT_STRING;
        field.type.element = global::rDSN.Tron.ServiceMethod.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceAPI that = obj as ServiceAPI;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceAPI other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceAPI that)
    {
        bool equals = true;
        
        equals = equals && ((this.Name == null) == (that.Name == null));
        equals = equals && (this.Name == null ? true : (this.Name.Length == that.Name.Length));
        equals = equals && ((this.Methods == null) == (that.Methods == null));
        equals = equals && ((this.Methods == null) ? true : (this.Methods.Count == that.Methods.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceAPI that)
    {
        bool equals = true;
        
        equals = equals && (this.Name == null ? true : this.Name == that.Name);
        if (equals && this.Methods != null && this.Methods.Count != 0)
        {
            foreach (var keyValPair1 in this.Methods)
            {
                global::rDSN.Tron.ServiceMethod val2 = default(global::rDSN.Tron.ServiceMethod);
                equals = equals && that.Methods.TryGetValue(keyValPair1.Key, out val2);
                if (equals)
                {
                        equals = equals && ((val2 == null) == (keyValPair1.Value == null));
                    equals = equals && (val2 == null ? true : val2.MemberwiseCompare(keyValPair1.Value));
                }
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Name, this.Name, separator);
        sb.AppendFormat(format, __internal.s_Methods, this.Methods, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServiceAPI

/// <summary>
/// ServiceSpecType
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public enum ServiceSpecType
{
                    
    Unknown,
    Composition,
    Common,
    Bond_3_0,
    Proto_Buffer_1_0,
    Thrift_0_9,
}; // enum ServiceSpecType


/// <summary>
/// ServiceSpec
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceSpec : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional rDSN.Tron.ServiceSpecType SType
    private global::rDSN.Tron.ServiceSpecType m_SType;

    // 2: Optional string MainSpecFile
    private String m_MainSpecFile;

    // 3: Optional vector<string> ReferencedSpecFiles
    private List<String> m_ReferencedSpecFiles;

    // 4: Optional string Directory
    private String m_Directory;

    /// <summary>
    /// SType
    /// </summary>
    public global::rDSN.Tron.ServiceSpecType SType
    {
        get { return this.m_SType; }
        set { this.m_SType = value; }
    }

    /// <summary>
    /// MainSpecFile
    /// </summary>
    public String MainSpecFile
    {
        get { return this.m_MainSpecFile; }
        set { this.m_MainSpecFile = value; }
    }

    /// <summary>
    /// ReferencedSpecFiles
    /// </summary>
    public List<String> ReferencedSpecFiles
    {
        get { return this.m_ReferencedSpecFiles; }
        set { this.m_ReferencedSpecFiles = value; }
    }

    /// <summary>
    /// Directory
    /// </summary>
    public String Directory
    {
        get { return this.m_Directory; }
        set { this.m_Directory = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata SType_meta = new Metadata();
        public static readonly Metadata MainSpecFile_meta = new Metadata();
        public static readonly Metadata ReferencedSpecFiles_meta = new Metadata();
        public static readonly Metadata Directory_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceSpec");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // SType
            SType_meta.name = "SType";
            SType_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            SType_meta.default_value.int_value = Convert.ToInt64(global::rDSN.Tron.ServiceSpecType.Unknown);

            // MainSpecFile
            MainSpecFile_meta.name = "MainSpecFile";
            MainSpecFile_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // ReferencedSpecFiles
            ReferencedSpecFiles_meta.name = "ReferencedSpecFiles";
            ReferencedSpecFiles_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Directory
            Directory_meta.name = "Directory";
            Directory_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int SType = 1;
        public const int MainSpecFile = 2;
        public const int ReferencedSpecFiles = 3;
        public const int Directory = 4;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_SType = "SType";
        public const String s_MainSpecFile = "MainSpecFile";
        public const String s_ReferencedSpecFiles = "ReferencedSpecFiles";
        public const String s_Directory = "Directory";
    }   // ~__internal

    // Constructor
    public ServiceSpec()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_SType = global::rDSN.Tron.ServiceSpecType.Unknown;
        m_MainSpecFile = string.Empty;
        if (m_ReferencedSpecFiles == null)
        {
            m_ReferencedSpecFiles = new List<String>();
        }
        else
        {
            m_ReferencedSpecFiles.Clear();
        }
        m_Directory = string.Empty;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceSpec cloned = new global::rDSN.Tron.ServiceSpec();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceSpec that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: rDSN.Tron.ServiceSpecType SType
        that.SType = this.SType;
        // 2: string MainSpecFile
        that.MainSpecFile = this.MainSpecFile;
        // 3: vector<string> ReferencedSpecFiles
        if (this.ReferencedSpecFiles != null)
        {
            if (that.ReferencedSpecFiles == null)
            {
                that.ReferencedSpecFiles = new List<String>();
            }
            else
            {
                that.ReferencedSpecFiles.Clear();
            }
            foreach (var iter1 in this.ReferencedSpecFiles)
            {
                String tmpItem2 = default(String);
                tmpItem2 = iter1;
                that.ReferencedSpecFiles.Add(tmpItem2);
            }
        }
        else
        {
            that.ReferencedSpecFiles = null;
        }
        // 4: string Directory
        that.Directory = this.Directory;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.SType = (global::rDSN.Tron.ServiceSpecType)reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.MainSpecFile = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_ReferencedSpecFiles(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Directory = reader.ReadString();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.SType:  // id=1
                    this.SType = (global::rDSN.Tron.ServiceSpecType)global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.MainSpecFile:  // id=2
                    this.MainSpecFile = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.ReferencedSpecFiles:  // id=3
                    this.ReadField_impl_ReferencedSpecFiles(reader, type);
                    break;
                case __ordinals.Directory:  // id=4
                    this.Directory = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_ReferencedSpecFiles(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        if (this.m_ReferencedSpecFiles.Capacity < count2)
        {
            this.m_ReferencedSpecFiles.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            String element3 = default(String);
             
            element3 = global::Microsoft.Bond.ReadHelper.ReadString(reader, elemType1);
            this.m_ReferencedSpecFiles.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_ReferencedSpecFiles


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceSpec))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.SType_meta.default_value.Equals(Convert.ToInt32(m_SType))))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.SType, Schema.SType_meta);
                writer.WriteInt32((Int32)m_SType);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.SType, Schema.SType_meta);
        }

        if (writeAllFields || (!Schema.MainSpecFile_meta.default_value.Equals(m_MainSpecFile)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainSpecFile, Schema.MainSpecFile_meta);
                writer.WriteString(m_MainSpecFile);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainSpecFile, Schema.MainSpecFile_meta);
        }

        UInt32 count1 = ((UInt32)m_ReferencedSpecFiles.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.ReferencedSpecFiles, Schema.ReferencedSpecFiles_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRING);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    writer.WriteString(m_ReferencedSpecFiles[idx2]);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.ReferencedSpecFiles, Schema.ReferencedSpecFiles_meta);
        }

        if (writeAllFields || (!Schema.Directory_meta.default_value.Equals(m_Directory)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Directory, Schema.Directory_meta);
                writer.WriteString(m_Directory);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Directory, Schema.Directory_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="SType";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = Convert.ToInt64(global::rDSN.Tron.ServiceSpecType.Unknown);
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="MainSpecFile";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="ReferencedSpecFiles";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="Directory";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceSpec that = obj as ServiceSpec;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceSpec other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceSpec that)
    {
        bool equals = true;
        
        equals = equals && ((this.SType == that.SType));
        equals = equals && ((this.MainSpecFile == null) == (that.MainSpecFile == null));
        equals = equals && (this.MainSpecFile == null ? true : (this.MainSpecFile.Length == that.MainSpecFile.Length));
        equals = equals && ((this.ReferencedSpecFiles == null) == (that.ReferencedSpecFiles == null));
        equals = equals && ((this.ReferencedSpecFiles == null) ? true : (this.ReferencedSpecFiles.Count == that.ReferencedSpecFiles.Count));
        equals = equals && ((this.Directory == null) == (that.Directory == null));
        equals = equals && (this.Directory == null ? true : (this.Directory.Length == that.Directory.Length));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceSpec that)
    {
        bool equals = true;
        
        equals = equals && (this.MainSpecFile == null ? true : this.MainSpecFile == that.MainSpecFile);
        if (equals && this.ReferencedSpecFiles != null && this.ReferencedSpecFiles.Count != 0)
        {
            var enum_1_1 = this.ReferencedSpecFiles.GetEnumerator();
            var enum_2_2 = that.ReferencedSpecFiles.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : (enum_1_1.Current.Length == enum_2_2.Current.Length));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current == enum_2_2.Current);
                if (!equals)
                {
                    break;
                }
            }
        }
        equals = equals && (this.Directory == null ? true : this.Directory == that.Directory);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_SType, this.SType, separator);
        sb.AppendFormat(format, __internal.s_MainSpecFile, this.MainSpecFile, separator);
        sb.AppendFormat(format, __internal.s_ReferencedSpecFiles, DumpList(this.ReferencedSpecFiles), separator);
        sb.AppendFormat(format, __internal.s_Directory, this.Directory, separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServiceSpec

/// <summary>
/// ServicePackage
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServicePackage : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Name
    private String m_Name;

    // 2: Optional string Author
    private String m_Author;

    // 3: Optional double Version
    private Double m_Version;

    // 4: Optional int64 PublishTime
    private Int64 m_PublishTime;

    // 5: Optional string Description
    private String m_Description;

    // 6: Optional string IconFileName
    private String m_IconFileName;

    // 7: Optional blob PackageZip
    private BondBlob m_PackageZip;

    // 8: Optional rDSN.Tron.ServiceSpec Spec
    private global::rDSN.Tron.ServiceSpec m_Spec;

    // 9: Optional string MainExecutableName
    private String m_MainExecutableName;

    // 10: Optional string Arguments
    private String m_Arguments;

    // 11: Optional string MainSpec
    private String m_MainSpec;

    // 12: Optional blob CompositionAssemblyContent
    private BondBlob m_CompositionAssemblyContent;

    /// <summary>
    /// Name
    /// </summary>
    public String Name
    {
        get { return this.m_Name; }
        set { this.m_Name = value; }
    }

    /// <summary>
    /// Author
    /// </summary>
    public String Author
    {
        get { return this.m_Author; }
        set { this.m_Author = value; }
    }

    /// <summary>
    /// Version
    /// </summary>
    public Double Version
    {
        get { return this.m_Version; }
        set { this.m_Version = value; }
    }

    /// <summary>
    /// PublishTime
    /// </summary>
    public Int64 PublishTime
    {
        get { return this.m_PublishTime; }
        set { this.m_PublishTime = value; }
    }

    /// <summary>
    /// Description
    /// </summary>
    public String Description
    {
        get { return this.m_Description; }
        set { this.m_Description = value; }
    }

    /// <summary>
    /// IconFileName
    /// </summary>
    public String IconFileName
    {
        get { return this.m_IconFileName; }
        set { this.m_IconFileName = value; }
    }

    /// <summary>
    /// PackageZip
    /// </summary>
    public BondBlob PackageZip
    {
        get { return this.m_PackageZip; }
        set { this.m_PackageZip = value; }
    }

    /// <summary>
    /// Spec
    /// </summary>
    public global::rDSN.Tron.ServiceSpec Spec
    {
        get { return this.m_Spec; }
        set { this.m_Spec = value; }
    }

    /// <summary>
    /// MainExecutableName
    /// </summary>
    public String MainExecutableName
    {
        get { return this.m_MainExecutableName; }
        set { this.m_MainExecutableName = value; }
    }

    /// <summary>
    /// Arguments
    /// </summary>
    public String Arguments
    {
        get { return this.m_Arguments; }
        set { this.m_Arguments = value; }
    }

    /// <summary>
    /// %port% is used for RPC port, which will be replaced by our scheduler at runtime
    /// </summary>
    public String MainSpec
    {
        get { return this.m_MainSpec; }
        set { this.m_MainSpec = value; }
    }

    /// <summary>
    /// for query
    /// </summary>
    public BondBlob CompositionAssemblyContent
    {
        get { return this.m_CompositionAssemblyContent; }
        set { this.m_CompositionAssemblyContent = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Name_meta = new Metadata();
        public static readonly Metadata Author_meta = new Metadata();
        public static readonly Metadata Version_meta = new Metadata();
        public static readonly Metadata PublishTime_meta = new Metadata();
        public static readonly Metadata Description_meta = new Metadata();
        public static readonly Metadata IconFileName_meta = new Metadata();
        public static readonly Metadata PackageZip_meta = new Metadata();
        public static readonly Metadata Spec_meta = new Metadata();
        public static readonly Metadata MainExecutableName_meta = new Metadata();
        public static readonly Metadata Arguments_meta = new Metadata();
        public static readonly Metadata MainSpec_meta = new Metadata();
        public static readonly Metadata CompositionAssemblyContent_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServicePackage");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Name
            Name_meta.name = "Name";
            Name_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Author
            Author_meta.name = "Author";
            Author_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Version
            Version_meta.name = "Version";
            Version_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            Version_meta.default_value.double_value = 0;

            // PublishTime
            PublishTime_meta.name = "PublishTime";
            PublishTime_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            PublishTime_meta.default_value.int_value = 0;

            // Description
            Description_meta.name = "Description";
            Description_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // IconFileName
            IconFileName_meta.name = "IconFileName";
            IconFileName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // PackageZip
            PackageZip_meta.name = "PackageZip";
            PackageZip_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Spec
            Spec_meta.name = "Spec";
            Spec_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // MainExecutableName
            MainExecutableName_meta.name = "MainExecutableName";
            MainExecutableName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Arguments
            Arguments_meta.name = "Arguments";
            Arguments_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // MainSpec
            MainSpec_meta.name = "MainSpec";
            MainSpec_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // CompositionAssemblyContent
            CompositionAssemblyContent_meta.name = "CompositionAssemblyContent";
            CompositionAssemblyContent_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Name = 1;
        public const int Author = 2;
        public const int Version = 3;
        public const int PublishTime = 4;
        public const int Description = 5;
        public const int IconFileName = 6;
        public const int PackageZip = 7;
        public const int Spec = 8;
        public const int MainExecutableName = 9;
        public const int Arguments = 10;
        public const int MainSpec = 11;
        public const int CompositionAssemblyContent = 12;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Name = "Name";
        public const String s_Author = "Author";
        public const String s_Version = "Version";
        public const String s_PublishTime = "PublishTime";
        public const String s_Description = "Description";
        public const String s_IconFileName = "IconFileName";
        public const String s_PackageZip = "PackageZip";
        public const String s_Spec = "Spec";
        public const String s_MainExecutableName = "MainExecutableName";
        public const String s_Arguments = "Arguments";
        public const String s_MainSpec = "MainSpec";
        public const String s_CompositionAssemblyContent = "CompositionAssemblyContent";
    }   // ~__internal

    // Constructor
    public ServicePackage()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Name = string.Empty;
        m_Author = string.Empty;
        m_Version = 0;
        m_PublishTime = 0;
        m_Description = string.Empty;
        m_IconFileName = string.Empty;
        m_PackageZip = new BondBlob();
        m_Spec = new global::rDSN.Tron.ServiceSpec();
        m_MainExecutableName = string.Empty;
        m_Arguments = string.Empty;
        m_MainSpec = string.Empty;
        m_CompositionAssemblyContent = new BondBlob();
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServicePackage cloned = new global::rDSN.Tron.ServicePackage();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServicePackage that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Name
        that.Name = this.Name;
        // 2: string Author
        that.Author = this.Author;
        // 3: double Version
        that.Version = this.Version;
        // 4: int64 PublishTime
        that.PublishTime = this.PublishTime;
        // 5: string Description
        that.Description = this.Description;
        // 6: string IconFileName
        that.IconFileName = this.IconFileName;
        // 7: blob PackageZip
        that.PackageZip = this.PackageZip.CloneData();
        // 8: rDSN.Tron.ServiceSpec Spec
        that.Spec = (this.Spec == null ? null : (global::rDSN.Tron.ServiceSpec)this.Spec.Clone());
        // 9: string MainExecutableName
        that.MainExecutableName = this.MainExecutableName;
        // 10: string Arguments
        that.Arguments = this.Arguments;
        // 11: string MainSpec
        that.MainSpec = this.MainSpec;
        // 12: blob CompositionAssemblyContent
        that.CompositionAssemblyContent = this.CompositionAssemblyContent.CloneData();
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Name = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Author = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Version = reader.ReadDouble();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.PublishTime = reader.ReadInt64();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Description = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.IconFileName = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.PackageZip = this.PackageZip.FromData(global::Microsoft.Bond.ReadHelper.ReadBlob(reader, global::Microsoft.Bond.BondDataType.BT_LIST));
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Spec.Read(reader);
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.MainExecutableName = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Arguments = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.MainSpec = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.CompositionAssemblyContent = this.CompositionAssemblyContent.FromData(global::Microsoft.Bond.ReadHelper.ReadBlob(reader, global::Microsoft.Bond.BondDataType.BT_LIST));
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Name:  // id=1
                    this.Name = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Author:  // id=2
                    this.Author = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Version:  // id=3
                    this.Version = global::Microsoft.Bond.ReadHelper.ReadDouble(reader, type);
                    break;
                case __ordinals.PublishTime:  // id=4
                    this.PublishTime = global::Microsoft.Bond.ReadHelper.ReadInt64(reader, type);
                    break;
                case __ordinals.Description:  // id=5
                    this.Description = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.IconFileName:  // id=6
                    this.IconFileName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.PackageZip:  // id=7
                    this.PackageZip = global::Microsoft.Bond.ReadHelper.ReadBlob(reader, type);
                    break;
                case __ordinals.Spec:  // id=8
                    global::Microsoft.Bond.ReadHelper.ValidateType(type, global::Microsoft.Bond.BondDataType.BT_STRUCT);
                    this.Spec.Read(reader);
                    break;
                case __ordinals.MainExecutableName:  // id=9
                    this.MainExecutableName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Arguments:  // id=10
                    this.Arguments = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.MainSpec:  // id=11
                    this.MainSpec = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.CompositionAssemblyContent:  // id=12
                    this.CompositionAssemblyContent = global::Microsoft.Bond.ReadHelper.ReadBlob(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServicePackage))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Name_meta.default_value.Equals(m_Name)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
                writer.WriteString(m_Name);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
        }

        if (writeAllFields || (!Schema.Author_meta.default_value.Equals(m_Author)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Author, Schema.Author_meta);
                writer.WriteString(m_Author);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Author, Schema.Author_meta);
        }

        if (writeAllFields || (!Schema.Version_meta.default_value.Equals(m_Version)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_DOUBLE, __ordinals.Version, Schema.Version_meta);
                writer.WriteDouble(m_Version);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_DOUBLE, __ordinals.Version, Schema.Version_meta);
        }

        if (writeAllFields || (!Schema.PublishTime_meta.default_value.Equals(m_PublishTime)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT64, __ordinals.PublishTime, Schema.PublishTime_meta);
                writer.WriteInt64(m_PublishTime);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT64, __ordinals.PublishTime, Schema.PublishTime_meta);
        }

        if (writeAllFields || (!Schema.Description_meta.default_value.Equals(m_Description)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Description, Schema.Description_meta);
                writer.WriteString(m_Description);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Description, Schema.Description_meta);
        }

        if (writeAllFields || (!Schema.IconFileName_meta.default_value.Equals(m_IconFileName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.IconFileName, Schema.IconFileName_meta);
                writer.WriteString(m_IconFileName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.IconFileName, Schema.IconFileName_meta);
        }

        UInt32 count1 = (m_PackageZip.GetCount());
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.PackageZip, Schema.PackageZip_meta);
                writer.WriteContainerBegin(count1, BondDataType.BT_INT8);
            writer.WriteBlob(m_PackageZip.GetData());
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.PackageZip, Schema.PackageZip_meta);
        }

        writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRUCT, __ordinals.Spec, Schema.Spec_meta);
            m_Spec.Write(writer, true);
        writer.WriteFieldEnd();
        if (writeAllFields || (!Schema.MainExecutableName_meta.default_value.Equals(m_MainExecutableName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainExecutableName, Schema.MainExecutableName_meta);
                writer.WriteString(m_MainExecutableName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainExecutableName, Schema.MainExecutableName_meta);
        }

        if (writeAllFields || (!Schema.Arguments_meta.default_value.Equals(m_Arguments)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Arguments, Schema.Arguments_meta);
                writer.WriteString(m_Arguments);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Arguments, Schema.Arguments_meta);
        }

        if (writeAllFields || (!Schema.MainSpec_meta.default_value.Equals(m_MainSpec)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainSpec, Schema.MainSpec_meta);
                writer.WriteString(m_MainSpec);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainSpec, Schema.MainSpec_meta);
        }

        UInt32 count2 = (m_CompositionAssemblyContent.GetCount());
        if (writeAllFields || count2 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.CompositionAssemblyContent, Schema.CompositionAssemblyContent_meta);
                writer.WriteContainerBegin(count2, BondDataType.BT_INT8);
            writer.WriteBlob(m_CompositionAssemblyContent.GetData());
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.CompositionAssemblyContent, Schema.CompositionAssemblyContent_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Name";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Author";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="Version";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.double_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_DOUBLE;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="PublishTime";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT64;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 5;
        field.metadata.name="Description";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 6;
        field.metadata.name="IconFileName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 7;
        field.metadata.name="PackageZip";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element.id = global::Microsoft.Bond.BondDataType.BT_INT8;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 8;
        field.metadata.name="Spec";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type = global::rDSN.Tron.ServiceSpec.GetTypeDef(schema);

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 9;
        field.metadata.name="MainExecutableName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 10;
        field.metadata.name="Arguments";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 11;
        field.metadata.name="MainSpec";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 12;
        field.metadata.name="CompositionAssemblyContent";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element.id = global::Microsoft.Bond.BondDataType.BT_INT8;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServicePackage that = obj as ServicePackage;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServicePackage other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServicePackage that)
    {
        bool equals = true;
        
        equals = equals && ((this.Name == null) == (that.Name == null));
        equals = equals && (this.Name == null ? true : (this.Name.Length == that.Name.Length));
        equals = equals && ((this.Author == null) == (that.Author == null));
        equals = equals && (this.Author == null ? true : (this.Author.Length == that.Author.Length));
        equals = equals && ((Double.IsNaN(this.Version) ? Double.IsNaN(that.Version) : (this.Version == that.Version)));
        equals = equals && ((this.PublishTime == that.PublishTime));
        equals = equals && ((this.Description == null) == (that.Description == null));
        equals = equals && (this.Description == null ? true : (this.Description.Length == that.Description.Length));
        equals = equals && ((this.IconFileName == null) == (that.IconFileName == null));
        equals = equals && (this.IconFileName == null ? true : (this.IconFileName.Length == that.IconFileName.Length));
        equals = equals && (this.PackageZip.GetCount() == that.PackageZip.GetCount());
        equals = equals && ((this.MainExecutableName == null) == (that.MainExecutableName == null));
        equals = equals && (this.MainExecutableName == null ? true : (this.MainExecutableName.Length == that.MainExecutableName.Length));
        equals = equals && ((this.Arguments == null) == (that.Arguments == null));
        equals = equals && (this.Arguments == null ? true : (this.Arguments.Length == that.Arguments.Length));
        equals = equals && ((this.MainSpec == null) == (that.MainSpec == null));
        equals = equals && (this.MainSpec == null ? true : (this.MainSpec.Length == that.MainSpec.Length));
        equals = equals && (this.CompositionAssemblyContent.GetCount() == that.CompositionAssemblyContent.GetCount());
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServicePackage that)
    {
        bool equals = true;
        
        equals = equals && (this.Name == null ? true : this.Name == that.Name);
        equals = equals && (this.Author == null ? true : this.Author == that.Author);
        equals = equals && (this.Description == null ? true : this.Description == that.Description);
        equals = equals && (this.IconFileName == null ? true : this.IconFileName == that.IconFileName);
        equals = equals && this.PackageZip.CompareData(that.PackageZip);
        equals = equals && (this.Spec == null ? true : this.Spec.MemberwiseCompare(that.Spec));
        equals = equals && (this.MainExecutableName == null ? true : this.MainExecutableName == that.MainExecutableName);
        equals = equals && (this.Arguments == null ? true : this.Arguments == that.Arguments);
        equals = equals && (this.MainSpec == null ? true : this.MainSpec == that.MainSpec);
        equals = equals && this.CompositionAssemblyContent.CompareData(that.CompositionAssemblyContent);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Name, this.Name, separator);
        sb.AppendFormat(format, __internal.s_Author, this.Author, separator);
        sb.AppendFormat(format, __internal.s_Version, this.Version, separator);
        sb.AppendFormat(format, __internal.s_PublishTime, this.PublishTime, separator);
        sb.AppendFormat(format, __internal.s_Description, this.Description, separator);
        sb.AppendFormat(format, __internal.s_IconFileName, this.IconFileName, separator);
        sb.AppendFormat(format, __internal.s_PackageZip, this.PackageZip, separator);
        sb.AppendFormat(format, __internal.s_Spec, this.Spec, separator);
        sb.AppendFormat(format, __internal.s_MainExecutableName, this.MainExecutableName, separator);
        sb.AppendFormat(format, __internal.s_Arguments, this.Arguments, separator);
        sb.AppendFormat(format, __internal.s_MainSpec, this.MainSpec, separator);
        sb.AppendFormat(format, __internal.s_CompositionAssemblyContent, this.CompositionAssemblyContent, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServicePackage

/// <summary>
/// ServiceDsptr
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceDsptr : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Name
    private String m_Name;

    // 2: Optional string Author
    private String m_Author;

    // 3: Optional double Version
    private Double m_Version;

    // 4: Optional string PublishTime
    private String m_PublishTime;

    // 5: Optional string Description
    private String m_Description;

    // 6: Optional string IconFileName
    private String m_IconFileName;

    // 7: Optional string MainSpec
    private String m_MainSpec;

    /// <summary>
    /// Name
    /// </summary>
    public String Name
    {
        get { return this.m_Name; }
        set { this.m_Name = value; }
    }

    /// <summary>
    /// Author
    /// </summary>
    public String Author
    {
        get { return this.m_Author; }
        set { this.m_Author = value; }
    }

    /// <summary>
    /// Version
    /// </summary>
    public Double Version
    {
        get { return this.m_Version; }
        set { this.m_Version = value; }
    }

    /// <summary>
    /// PublishTime
    /// </summary>
    public String PublishTime
    {
        get { return this.m_PublishTime; }
        set { this.m_PublishTime = value; }
    }

    /// <summary>
    /// Description
    /// </summary>
    public String Description
    {
        get { return this.m_Description; }
        set { this.m_Description = value; }
    }

    /// <summary>
    /// IconFileName
    /// </summary>
    public String IconFileName
    {
        get { return this.m_IconFileName; }
        set { this.m_IconFileName = value; }
    }

    /// <summary>
    /// MainSpec
    /// </summary>
    public String MainSpec
    {
        get { return this.m_MainSpec; }
        set { this.m_MainSpec = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Name_meta = new Metadata();
        public static readonly Metadata Author_meta = new Metadata();
        public static readonly Metadata Version_meta = new Metadata();
        public static readonly Metadata PublishTime_meta = new Metadata();
        public static readonly Metadata Description_meta = new Metadata();
        public static readonly Metadata IconFileName_meta = new Metadata();
        public static readonly Metadata MainSpec_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceDsptr");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Name
            Name_meta.name = "Name";
            Name_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Author
            Author_meta.name = "Author";
            Author_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Version
            Version_meta.name = "Version";
            Version_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            Version_meta.default_value.double_value = 0;

            // PublishTime
            PublishTime_meta.name = "PublishTime";
            PublishTime_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Description
            Description_meta.name = "Description";
            Description_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // IconFileName
            IconFileName_meta.name = "IconFileName";
            IconFileName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // MainSpec
            MainSpec_meta.name = "MainSpec";
            MainSpec_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Name = 1;
        public const int Author = 2;
        public const int Version = 3;
        public const int PublishTime = 4;
        public const int Description = 5;
        public const int IconFileName = 6;
        public const int MainSpec = 7;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Name = "Name";
        public const String s_Author = "Author";
        public const String s_Version = "Version";
        public const String s_PublishTime = "PublishTime";
        public const String s_Description = "Description";
        public const String s_IconFileName = "IconFileName";
        public const String s_MainSpec = "MainSpec";
    }   // ~__internal

    // Constructor
    public ServiceDsptr()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Name = string.Empty;
        m_Author = string.Empty;
        m_Version = 0;
        m_PublishTime = string.Empty;
        m_Description = string.Empty;
        m_IconFileName = string.Empty;
        m_MainSpec = string.Empty;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceDsptr cloned = new global::rDSN.Tron.ServiceDsptr();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceDsptr that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Name
        that.Name = this.Name;
        // 2: string Author
        that.Author = this.Author;
        // 3: double Version
        that.Version = this.Version;
        // 4: string PublishTime
        that.PublishTime = this.PublishTime;
        // 5: string Description
        that.Description = this.Description;
        // 6: string IconFileName
        that.IconFileName = this.IconFileName;
        // 7: string MainSpec
        that.MainSpec = this.MainSpec;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Name = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Author = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Version = reader.ReadDouble();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.PublishTime = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Description = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.IconFileName = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.MainSpec = reader.ReadString();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Name:  // id=1
                    this.Name = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Author:  // id=2
                    this.Author = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Version:  // id=3
                    this.Version = global::Microsoft.Bond.ReadHelper.ReadDouble(reader, type);
                    break;
                case __ordinals.PublishTime:  // id=4
                    this.PublishTime = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Description:  // id=5
                    this.Description = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.IconFileName:  // id=6
                    this.IconFileName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.MainSpec:  // id=7
                    this.MainSpec = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceDsptr))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Name_meta.default_value.Equals(m_Name)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
                writer.WriteString(m_Name);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
        }

        if (writeAllFields || (!Schema.Author_meta.default_value.Equals(m_Author)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Author, Schema.Author_meta);
                writer.WriteString(m_Author);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Author, Schema.Author_meta);
        }

        if (writeAllFields || (!Schema.Version_meta.default_value.Equals(m_Version)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_DOUBLE, __ordinals.Version, Schema.Version_meta);
                writer.WriteDouble(m_Version);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_DOUBLE, __ordinals.Version, Schema.Version_meta);
        }

        if (writeAllFields || (!Schema.PublishTime_meta.default_value.Equals(m_PublishTime)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.PublishTime, Schema.PublishTime_meta);
                writer.WriteString(m_PublishTime);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.PublishTime, Schema.PublishTime_meta);
        }

        if (writeAllFields || (!Schema.Description_meta.default_value.Equals(m_Description)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Description, Schema.Description_meta);
                writer.WriteString(m_Description);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Description, Schema.Description_meta);
        }

        if (writeAllFields || (!Schema.IconFileName_meta.default_value.Equals(m_IconFileName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.IconFileName, Schema.IconFileName_meta);
                writer.WriteString(m_IconFileName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.IconFileName, Schema.IconFileName_meta);
        }

        if (writeAllFields || (!Schema.MainSpec_meta.default_value.Equals(m_MainSpec)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainSpec, Schema.MainSpec_meta);
                writer.WriteString(m_MainSpec);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.MainSpec, Schema.MainSpec_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Name";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Author";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="Version";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.double_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_DOUBLE;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="PublishTime";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 5;
        field.metadata.name="Description";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 6;
        field.metadata.name="IconFileName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 7;
        field.metadata.name="MainSpec";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceDsptr that = obj as ServiceDsptr;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceDsptr other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceDsptr that)
    {
        bool equals = true;
        
        equals = equals && ((this.Name == null) == (that.Name == null));
        equals = equals && (this.Name == null ? true : (this.Name.Length == that.Name.Length));
        equals = equals && ((this.Author == null) == (that.Author == null));
        equals = equals && (this.Author == null ? true : (this.Author.Length == that.Author.Length));
        equals = equals && ((Double.IsNaN(this.Version) ? Double.IsNaN(that.Version) : (this.Version == that.Version)));
        equals = equals && ((this.PublishTime == null) == (that.PublishTime == null));
        equals = equals && (this.PublishTime == null ? true : (this.PublishTime.Length == that.PublishTime.Length));
        equals = equals && ((this.Description == null) == (that.Description == null));
        equals = equals && (this.Description == null ? true : (this.Description.Length == that.Description.Length));
        equals = equals && ((this.IconFileName == null) == (that.IconFileName == null));
        equals = equals && (this.IconFileName == null ? true : (this.IconFileName.Length == that.IconFileName.Length));
        equals = equals && ((this.MainSpec == null) == (that.MainSpec == null));
        equals = equals && (this.MainSpec == null ? true : (this.MainSpec.Length == that.MainSpec.Length));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceDsptr that)
    {
        bool equals = true;
        
        equals = equals && (this.Name == null ? true : this.Name == that.Name);
        equals = equals && (this.Author == null ? true : this.Author == that.Author);
        equals = equals && (this.PublishTime == null ? true : this.PublishTime == that.PublishTime);
        equals = equals && (this.Description == null ? true : this.Description == that.Description);
        equals = equals && (this.IconFileName == null ? true : this.IconFileName == that.IconFileName);
        equals = equals && (this.MainSpec == null ? true : this.MainSpec == that.MainSpec);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Name, this.Name, separator);
        sb.AppendFormat(format, __internal.s_Author, this.Author, separator);
        sb.AppendFormat(format, __internal.s_Version, this.Version, separator);
        sb.AppendFormat(format, __internal.s_PublishTime, this.PublishTime, separator);
        sb.AppendFormat(format, __internal.s_Description, this.Description, separator);
        sb.AppendFormat(format, __internal.s_IconFileName, this.IconFileName, separator);
        sb.AppendFormat(format, __internal.s_MainSpec, this.MainSpec, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServiceDsptr

/// <summary>
/// RpcError
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class RpcError : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional int32 Code
    private Int32 m_Code;

    /// <summary>
    /// Code
    /// </summary>
    public Int32 Code
    {
        get { return this.m_Code; }
        set { this.m_Code = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Code_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("RpcError");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Code
            Code_meta.name = "Code";
            Code_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            Code_meta.default_value.int_value = 0;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Code = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Code = "Code";
    }   // ~__internal

    // Constructor
    public RpcError()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Code = 0;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.RpcError cloned = new global::rDSN.Tron.RpcError();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.RpcError that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: int32 Code
        that.Code = this.Code;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Code = reader.ReadInt32();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Code:  // id=1
                    this.Code = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(RpcError))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Code_meta.default_value.Equals(m_Code)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Code, Schema.Code_meta);
                writer.WriteInt32(m_Code);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Code, Schema.Code_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Code";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        RpcError that = obj as RpcError;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(RpcError other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(RpcError that)
    {
        bool equals = true;
        
        equals = equals && ((this.Code == that.Code));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(RpcError that)
    {
        bool equals = true;
        
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Code, this.Code, separator);
        
        return sb.ToString();
    } // ToString()

}; // class RpcError

/// <summary>
/// RpcResponse{T}
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class RpcResponse<T> : global::rDSN.Tron.RpcError
{
    //
    // Fields
    //

    // 2: Optional T Value
    private T m_Value;

    /// <summary>
    /// Value
    /// </summary>
    public T Value
    {
        get { return this.m_Value; }
        set { this.m_Value = value; }
    }

    new public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Value_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("RpcResponse");
            runtimeName.Append("<");
            runtimeName.Append(GenericHelper.GetIdlTypeName(typeof(T)));
            runtimeName.Append(">");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Value
            Value_meta.name = "Value";
            Value_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Value = 2;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Value = "Value";
    }   // ~__internal

    // Constructor
    public RpcResponse()
    {
        
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public override void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected new void Reset(string name, string qualifiedName)
    {
        base.Reset(name, qualifiedName);
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Value = GenericHelper.Create<T>();
    } // ResetImpl()

    public override IBondSerializable Clone()
    {
        global::rDSN.Tron.RpcResponse<T> cloned = new global::rDSN.Tron.RpcResponse<T>();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.RpcResponse<T> that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        base.CopyTo(that);
        // 2: T Value
        that.Value = (T)global::Microsoft.Bond.GenericHelper.Clone(this.Value);
    }    // ~CopyTo


    public override void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public override void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public override void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public override void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected new  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        
        base.ReadUntagged(reader);

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Value(reader, global::Microsoft.Bond.GenericHelper.GetBondDataType(typeof(T)));
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected new  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        
        base.Read(reader, out isPartialStruct);

        if (!isPartialStruct)
        {
            return;
        }        

        reader.ReadStructBegin(false);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Value:  // id=2
                    this.ReadField_impl_Value(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Value(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
 
        global::Microsoft.Bond.GenericHelper.Read<T>(ref this.m_Value, reader, typeInPayload);
    } // ReadField_impl_Value


    override public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    override public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    new public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    override public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(RpcResponse<T>))
        {
            Write(writer, true);
        }
        else
        {
            base.Write(writer, type);
        }
    }

    new protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	    base.WriteInternal(writer, false);            

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, false);

                GenericHelper.WriteField(writer, __ordinals.Value, Schema.Value_meta, m_Value, typeof(T));
        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public override IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static new public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static new public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static new protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        structDef.base_def = global::rDSN.Tron.RpcError.GetTypeDef(schema);
        

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Value";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type = GenericHelper.CreateTypeDef(schema, typeof (T));

        structDef.fields.Add(field);

        return pos;
    }
 
    public override bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        RpcResponse<T> that = obj as RpcResponse<T>;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(RpcResponse<T> other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(RpcResponse<T> that)
    {
        bool equals = true;
        equals = equals && base.MemberwiseCompareQuick(that);
        equals = equals && (global::Microsoft.Bond.GenericHelper.Compare(this.Value, that.Value));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(RpcResponse<T> that)
    {
        bool equals = true;
        equals = equals && base.MemberwiseCompareDeep(that);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public new string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Value, this.Value, separator);
        
        return sb.ToString();
    } // ToString()

}; // class RpcResponse<T>

/// <summary>
/// Name
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class Name : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Value
    private String m_Value;

    /// <summary>
    /// Value
    /// </summary>
    public String Value
    {
        get { return this.m_Value; }
        set { this.m_Value = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Value_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("Name");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Value
            Value_meta.name = "Value";
            Value_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Value = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Value = "Value";
    }   // ~__internal

    // Constructor
    public Name()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Value = string.Empty;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.Name cloned = new global::rDSN.Tron.Name();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.Name that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Value
        that.Value = this.Value;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Value = reader.ReadString();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Value:  // id=1
                    this.Value = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(Name))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Value_meta.default_value.Equals(m_Value)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Value, Schema.Value_meta);
                writer.WriteString(m_Value);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Value, Schema.Value_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Value";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        Name that = obj as Name;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(Name other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(Name that)
    {
        bool equals = true;
        
        equals = equals && ((this.Value == null) == (that.Value == null));
        equals = equals && (this.Value == null ? true : (this.Value.Length == that.Value.Length));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(Name that)
    {
        bool equals = true;
        
        equals = equals && (this.Value == null ? true : this.Value == that.Value);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Value, this.Value, separator);
        
        return sb.ToString();
    } // ToString()

}; // class Name

/// <summary>
/// NameList
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class NameList : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional vector<string> Names
    private List<String> m_Names;

    /// <summary>
    /// Names
    /// </summary>
    public List<String> Names
    {
        get { return this.m_Names; }
        set { this.m_Names = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Names_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("NameList");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Names
            Names_meta.name = "Names";
            Names_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Names = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Names = "Names";
    }   // ~__internal

    // Constructor
    public NameList()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Names == null)
        {
            m_Names = new List<String>();
        }
        else
        {
            m_Names.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.NameList cloned = new global::rDSN.Tron.NameList();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.NameList that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: vector<string> Names
        if (this.Names != null)
        {
            if (that.Names == null)
            {
                that.Names = new List<String>();
            }
            else
            {
                that.Names.Clear();
            }
            foreach (var iter1 in this.Names)
            {
                String tmpItem2 = default(String);
                tmpItem2 = iter1;
                that.Names.Add(tmpItem2);
            }
        }
        else
        {
            that.Names = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Names(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Names:  // id=1
                    this.ReadField_impl_Names(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Names(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        if (this.m_Names.Capacity < count2)
        {
            this.m_Names.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            String element3 = default(String);
             
            element3 = global::Microsoft.Bond.ReadHelper.ReadString(reader, elemType1);
            this.m_Names.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Names


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(NameList))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        UInt32 count1 = ((UInt32)m_Names.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Names, Schema.Names_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRING);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    writer.WriteString(m_Names[idx2]);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Names, Schema.Names_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Names";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        NameList that = obj as NameList;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(NameList other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(NameList that)
    {
        bool equals = true;
        
        equals = equals && ((this.Names == null) == (that.Names == null));
        equals = equals && ((this.Names == null) ? true : (this.Names.Count == that.Names.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(NameList that)
    {
        bool equals = true;
        
        if (equals && this.Names != null && this.Names.Count != 0)
        {
            var enum_1_1 = this.Names.GetEnumerator();
            var enum_2_2 = that.Names.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : (enum_1_1.Current.Length == enum_2_2.Current.Length));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current == enum_2_2.Current);
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Names, DumpList(this.Names), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class NameList

/// <summary>
/// NodeAddress
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class NodeAddress : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Host
    private String m_Host;

    // 2: Optional int32 Port
    private Int32 m_Port;

    /// <summary>
    /// Host
    /// </summary>
    public String Host
    {
        get { return this.m_Host; }
        set { this.m_Host = value; }
    }

    /// <summary>
    /// Port
    /// </summary>
    public Int32 Port
    {
        get { return this.m_Port; }
        set { this.m_Port = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Host_meta = new Metadata();
        public static readonly Metadata Port_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("NodeAddress");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Host
            Host_meta.name = "Host";
            Host_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Port
            Port_meta.name = "Port";
            Port_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            Port_meta.default_value.int_value = 0;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Host = 1;
        public const int Port = 2;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Host = "Host";
        public const String s_Port = "Port";
    }   // ~__internal

    // Constructor
    public NodeAddress()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Host = string.Empty;
        m_Port = 0;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.NodeAddress cloned = new global::rDSN.Tron.NodeAddress();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.NodeAddress that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Host
        that.Host = this.Host;
        // 2: int32 Port
        that.Port = this.Port;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Host = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Port = reader.ReadInt32();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Host:  // id=1
                    this.Host = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Port:  // id=2
                    this.Port = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(NodeAddress))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Host_meta.default_value.Equals(m_Host)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Host, Schema.Host_meta);
                writer.WriteString(m_Host);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Host, Schema.Host_meta);
        }

        if (writeAllFields || (!Schema.Port_meta.default_value.Equals(m_Port)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Port, Schema.Port_meta);
                writer.WriteInt32(m_Port);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Port, Schema.Port_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Host";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Port";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        NodeAddress that = obj as NodeAddress;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(NodeAddress other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(NodeAddress that)
    {
        bool equals = true;
        
        equals = equals && ((this.Host == null) == (that.Host == null));
        equals = equals && (this.Host == null ? true : (this.Host.Length == that.Host.Length));
        equals = equals && ((this.Port == that.Port));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(NodeAddress that)
    {
        bool equals = true;
        
        equals = equals && (this.Host == null ? true : this.Host == that.Host);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Host, this.Host, separator);
        sb.AppendFormat(format, __internal.s_Port, this.Port, separator);
        
        return sb.ToString();
    } // ToString()

}; // class NodeAddress

/// <summary>
/// ServiceInfo
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceInfo : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Name
    private String m_Name;

    // 2: Optional int32 InternalServiceSequenceId
    private Int32 m_InternalServiceSequenceId;

    // 3: Optional int32 PartitionCount
    private Int32 m_PartitionCount;

    // 4: Optional string ServicePackageName
    private String m_ServicePackageName;

    /// <summary>
    /// Name
    /// </summary>
    public String Name
    {
        get { return this.m_Name; }
        set { this.m_Name = value; }
    }

    /// <summary>
    /// InternalServiceSequenceId
    /// </summary>
    public Int32 InternalServiceSequenceId
    {
        get { return this.m_InternalServiceSequenceId; }
        set { this.m_InternalServiceSequenceId = value; }
    }

    /// <summary>
    /// PartitionCount
    /// </summary>
    public Int32 PartitionCount
    {
        get { return this.m_PartitionCount; }
        set { this.m_PartitionCount = value; }
    }

    /// <summary>
    /// ServicePackageName
    /// </summary>
    public String ServicePackageName
    {
        get { return this.m_ServicePackageName; }
        set { this.m_ServicePackageName = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Name_meta = new Metadata();
        public static readonly Metadata InternalServiceSequenceId_meta = new Metadata();
        public static readonly Metadata PartitionCount_meta = new Metadata();
        public static readonly Metadata ServicePackageName_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceInfo");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Name
            Name_meta.name = "Name";
            Name_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // InternalServiceSequenceId
            InternalServiceSequenceId_meta.name = "InternalServiceSequenceId";
            InternalServiceSequenceId_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            InternalServiceSequenceId_meta.default_value.int_value = 0;

            // PartitionCount
            PartitionCount_meta.name = "PartitionCount";
            PartitionCount_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            PartitionCount_meta.default_value.int_value = 0;

            // ServicePackageName
            ServicePackageName_meta.name = "ServicePackageName";
            ServicePackageName_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Name = 1;
        public const int InternalServiceSequenceId = 2;
        public const int PartitionCount = 3;
        public const int ServicePackageName = 4;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Name = "Name";
        public const String s_InternalServiceSequenceId = "InternalServiceSequenceId";
        public const String s_PartitionCount = "PartitionCount";
        public const String s_ServicePackageName = "ServicePackageName";
    }   // ~__internal

    // Constructor
    public ServiceInfo()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Name = string.Empty;
        m_InternalServiceSequenceId = 0;
        m_PartitionCount = 0;
        m_ServicePackageName = string.Empty;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceInfo cloned = new global::rDSN.Tron.ServiceInfo();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceInfo that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Name
        that.Name = this.Name;
        // 2: int32 InternalServiceSequenceId
        that.InternalServiceSequenceId = this.InternalServiceSequenceId;
        // 3: int32 PartitionCount
        that.PartitionCount = this.PartitionCount;
        // 4: string ServicePackageName
        that.ServicePackageName = this.ServicePackageName;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Name = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.InternalServiceSequenceId = reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.PartitionCount = reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ServicePackageName = reader.ReadString();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Name:  // id=1
                    this.Name = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.InternalServiceSequenceId:  // id=2
                    this.InternalServiceSequenceId = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.PartitionCount:  // id=3
                    this.PartitionCount = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.ServicePackageName:  // id=4
                    this.ServicePackageName = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceInfo))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Name_meta.default_value.Equals(m_Name)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
                writer.WriteString(m_Name);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
        }

        if (writeAllFields || (!Schema.InternalServiceSequenceId_meta.default_value.Equals(m_InternalServiceSequenceId)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.InternalServiceSequenceId, Schema.InternalServiceSequenceId_meta);
                writer.WriteInt32(m_InternalServiceSequenceId);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.InternalServiceSequenceId, Schema.InternalServiceSequenceId_meta);
        }

        if (writeAllFields || (!Schema.PartitionCount_meta.default_value.Equals(m_PartitionCount)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.PartitionCount, Schema.PartitionCount_meta);
                writer.WriteInt32(m_PartitionCount);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.PartitionCount, Schema.PartitionCount_meta);
        }

        if (writeAllFields || (!Schema.ServicePackageName_meta.default_value.Equals(m_ServicePackageName)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.ServicePackageName, Schema.ServicePackageName_meta);
                writer.WriteString(m_ServicePackageName);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.ServicePackageName, Schema.ServicePackageName_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Name";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="InternalServiceSequenceId";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="PartitionCount";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="ServicePackageName";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceInfo that = obj as ServiceInfo;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceInfo other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceInfo that)
    {
        bool equals = true;
        
        equals = equals && ((this.Name == null) == (that.Name == null));
        equals = equals && (this.Name == null ? true : (this.Name.Length == that.Name.Length));
        equals = equals && ((this.InternalServiceSequenceId == that.InternalServiceSequenceId));
        equals = equals && ((this.PartitionCount == that.PartitionCount));
        equals = equals && ((this.ServicePackageName == null) == (that.ServicePackageName == null));
        equals = equals && (this.ServicePackageName == null ? true : (this.ServicePackageName.Length == that.ServicePackageName.Length));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceInfo that)
    {
        bool equals = true;
        
        equals = equals && (this.Name == null ? true : this.Name == that.Name);
        equals = equals && (this.ServicePackageName == null ? true : this.ServicePackageName == that.ServicePackageName);
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Name, this.Name, separator);
        sb.AppendFormat(format, __internal.s_InternalServiceSequenceId, this.InternalServiceSequenceId, separator);
        sb.AppendFormat(format, __internal.s_PartitionCount, this.PartitionCount, separator);
        sb.AppendFormat(format, __internal.s_ServicePackageName, this.ServicePackageName, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServiceInfo

/// <summary>
/// ServicePartitionInfo
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServicePartitionInfo : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional int32 InternalServiceSequenceId
    private Int32 m_InternalServiceSequenceId;

    // 2: Optional int32 Index
    private Int32 m_Index;

    // 3: Optional uint64 GlobalPartitionId
    private UInt64 m_GlobalPartitionId;

    // 4: Optional string Name
    private String m_Name;

    // 5: Optional int32 ConfigurationVersion
    private Int32 m_ConfigurationVersion;

    // 6: Optional int32 ServicePort
    private Int32 m_ServicePort;

    // 7: Optional rDSN.Tron.NodeAddress ManagerAddress
    private global::rDSN.Tron.NodeAddress m_ManagerAddress;

    /// <summary>
    /// InternalServiceSequenceId
    /// </summary>
    public Int32 InternalServiceSequenceId
    {
        get { return this.m_InternalServiceSequenceId; }
        set { this.m_InternalServiceSequenceId = value; }
    }

    /// <summary>
    /// Index
    /// </summary>
    public Int32 Index
    {
        get { return this.m_Index; }
        set { this.m_Index = value; }
    }

    /// <summary>
    /// GlobalPartitionId
    /// </summary>
    public UInt64 GlobalPartitionId
    {
        get { return this.m_GlobalPartitionId; }
        set { this.m_GlobalPartitionId = value; }
    }

    /// <summary>
    /// InternalServiceSequenceId ## Index
    /// </summary>
    public String Name
    {
        get { return this.m_Name; }
        set { this.m_Name = value; }
    }

    /// <summary>
    /// ConfigurationVersion
    /// </summary>
    public Int32 ConfigurationVersion
    {
        get { return this.m_ConfigurationVersion; }
        set { this.m_ConfigurationVersion = value; }
    }

    /// <summary>
    /// ServicePort
    /// </summary>
    public Int32 ServicePort
    {
        get { return this.m_ServicePort; }
        set { this.m_ServicePort = value; }
    }

    /// <summary>
    /// ManagerAddress
    /// </summary>
    public global::rDSN.Tron.NodeAddress ManagerAddress
    {
        get { return this.m_ManagerAddress; }
        set { this.m_ManagerAddress = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata InternalServiceSequenceId_meta = new Metadata();
        public static readonly Metadata Index_meta = new Metadata();
        public static readonly Metadata GlobalPartitionId_meta = new Metadata();
        public static readonly Metadata Name_meta = new Metadata();
        public static readonly Metadata ConfigurationVersion_meta = new Metadata();
        public static readonly Metadata ServicePort_meta = new Metadata();
        public static readonly Metadata ManagerAddress_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServicePartitionInfo");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // InternalServiceSequenceId
            InternalServiceSequenceId_meta.name = "InternalServiceSequenceId";
            InternalServiceSequenceId_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            InternalServiceSequenceId_meta.default_value.int_value = 0;

            // Index
            Index_meta.name = "Index";
            Index_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            Index_meta.default_value.int_value = 0;

            // GlobalPartitionId
            GlobalPartitionId_meta.name = "GlobalPartitionId";
            GlobalPartitionId_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            GlobalPartitionId_meta.default_value.uint_value = 0;

            // Name
            Name_meta.name = "Name";
            Name_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // ConfigurationVersion
            ConfigurationVersion_meta.name = "ConfigurationVersion";
            ConfigurationVersion_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            ConfigurationVersion_meta.default_value.int_value = 0;

            // ServicePort
            ServicePort_meta.name = "ServicePort";
            ServicePort_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            ServicePort_meta.default_value.int_value = 0;

            // ManagerAddress
            ManagerAddress_meta.name = "ManagerAddress";
            ManagerAddress_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int InternalServiceSequenceId = 1;
        public const int Index = 2;
        public const int GlobalPartitionId = 3;
        public const int Name = 4;
        public const int ConfigurationVersion = 5;
        public const int ServicePort = 6;
        public const int ManagerAddress = 7;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_InternalServiceSequenceId = "InternalServiceSequenceId";
        public const String s_Index = "Index";
        public const String s_GlobalPartitionId = "GlobalPartitionId";
        public const String s_Name = "Name";
        public const String s_ConfigurationVersion = "ConfigurationVersion";
        public const String s_ServicePort = "ServicePort";
        public const String s_ManagerAddress = "ManagerAddress";
    }   // ~__internal

    // Constructor
    public ServicePartitionInfo()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_InternalServiceSequenceId = 0;
        m_Index = 0;
        m_GlobalPartitionId = 0;
        m_Name = string.Empty;
        m_ConfigurationVersion = 0;
        m_ServicePort = 0;
        m_ManagerAddress = new global::rDSN.Tron.NodeAddress();
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServicePartitionInfo cloned = new global::rDSN.Tron.ServicePartitionInfo();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServicePartitionInfo that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: int32 InternalServiceSequenceId
        that.InternalServiceSequenceId = this.InternalServiceSequenceId;
        // 2: int32 Index
        that.Index = this.Index;
        // 3: uint64 GlobalPartitionId
        that.GlobalPartitionId = this.GlobalPartitionId;
        // 4: string Name
        that.Name = this.Name;
        // 5: int32 ConfigurationVersion
        that.ConfigurationVersion = this.ConfigurationVersion;
        // 6: int32 ServicePort
        that.ServicePort = this.ServicePort;
        // 7: rDSN.Tron.NodeAddress ManagerAddress
        that.ManagerAddress = (this.ManagerAddress == null ? null : (global::rDSN.Tron.NodeAddress)this.ManagerAddress.Clone());
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.InternalServiceSequenceId = reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Index = reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.GlobalPartitionId = reader.ReadUInt64();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Name = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ConfigurationVersion = reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ServicePort = reader.ReadInt32();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ManagerAddress.Read(reader);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.InternalServiceSequenceId:  // id=1
                    this.InternalServiceSequenceId = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.Index:  // id=2
                    this.Index = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.GlobalPartitionId:  // id=3
                    this.GlobalPartitionId = global::Microsoft.Bond.ReadHelper.ReadUInt64(reader, type);
                    break;
                case __ordinals.Name:  // id=4
                    this.Name = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.ConfigurationVersion:  // id=5
                    this.ConfigurationVersion = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.ServicePort:  // id=6
                    this.ServicePort = global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                case __ordinals.ManagerAddress:  // id=7
                    global::Microsoft.Bond.ReadHelper.ValidateType(type, global::Microsoft.Bond.BondDataType.BT_STRUCT);
                    this.ManagerAddress.Read(reader);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServicePartitionInfo))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.InternalServiceSequenceId_meta.default_value.Equals(m_InternalServiceSequenceId)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.InternalServiceSequenceId, Schema.InternalServiceSequenceId_meta);
                writer.WriteInt32(m_InternalServiceSequenceId);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.InternalServiceSequenceId, Schema.InternalServiceSequenceId_meta);
        }

        if (writeAllFields || (!Schema.Index_meta.default_value.Equals(m_Index)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Index, Schema.Index_meta);
                writer.WriteInt32(m_Index);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Index, Schema.Index_meta);
        }

        if (writeAllFields || (!Schema.GlobalPartitionId_meta.default_value.Equals(m_GlobalPartitionId)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_UINT64, __ordinals.GlobalPartitionId, Schema.GlobalPartitionId_meta);
                writer.WriteUInt64(m_GlobalPartitionId);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_UINT64, __ordinals.GlobalPartitionId, Schema.GlobalPartitionId_meta);
        }

        if (writeAllFields || (!Schema.Name_meta.default_value.Equals(m_Name)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
                writer.WriteString(m_Name);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Name, Schema.Name_meta);
        }

        if (writeAllFields || (!Schema.ConfigurationVersion_meta.default_value.Equals(m_ConfigurationVersion)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.ConfigurationVersion, Schema.ConfigurationVersion_meta);
                writer.WriteInt32(m_ConfigurationVersion);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.ConfigurationVersion, Schema.ConfigurationVersion_meta);
        }

        if (writeAllFields || (!Schema.ServicePort_meta.default_value.Equals(m_ServicePort)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.ServicePort, Schema.ServicePort_meta);
                writer.WriteInt32(m_ServicePort);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.ServicePort, Schema.ServicePort_meta);
        }

        writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRUCT, __ordinals.ManagerAddress, Schema.ManagerAddress_meta);
            m_ManagerAddress.Write(writer, true);
        writer.WriteFieldEnd();
        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="InternalServiceSequenceId";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Index";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="GlobalPartitionId";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.uint_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_UINT64;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="Name";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 5;
        field.metadata.name="ConfigurationVersion";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 6;
        field.metadata.name="ServicePort";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = 0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 7;
        field.metadata.name="ManagerAddress";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type = global::rDSN.Tron.NodeAddress.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServicePartitionInfo that = obj as ServicePartitionInfo;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServicePartitionInfo other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServicePartitionInfo that)
    {
        bool equals = true;
        
        equals = equals && ((this.InternalServiceSequenceId == that.InternalServiceSequenceId));
        equals = equals && ((this.Index == that.Index));
        equals = equals && ((this.GlobalPartitionId == that.GlobalPartitionId));
        equals = equals && ((this.Name == null) == (that.Name == null));
        equals = equals && (this.Name == null ? true : (this.Name.Length == that.Name.Length));
        equals = equals && ((this.ConfigurationVersion == that.ConfigurationVersion));
        equals = equals && ((this.ServicePort == that.ServicePort));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServicePartitionInfo that)
    {
        bool equals = true;
        
        equals = equals && (this.Name == null ? true : this.Name == that.Name);
        equals = equals && (this.ManagerAddress == null ? true : this.ManagerAddress.MemberwiseCompare(that.ManagerAddress));
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_InternalServiceSequenceId, this.InternalServiceSequenceId, separator);
        sb.AppendFormat(format, __internal.s_Index, this.Index, separator);
        sb.AppendFormat(format, __internal.s_GlobalPartitionId, this.GlobalPartitionId, separator);
        sb.AppendFormat(format, __internal.s_Name, this.Name, separator);
        sb.AppendFormat(format, __internal.s_ConfigurationVersion, this.ConfigurationVersion, separator);
        sb.AppendFormat(format, __internal.s_ServicePort, this.ServicePort, separator);
        sb.AppendFormat(format, __internal.s_ManagerAddress, this.ManagerAddress, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServicePartitionInfo

/// <summary>
/// ServiceInfoEx
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceInfoEx : global::rDSN.Tron.ServiceInfo
{
    //
    // Fields
    //

    // 1: Optional vector<rDSN.Tron.ServicePartitionInfo> Partitions
    private List<global::rDSN.Tron.ServicePartitionInfo> m_Partitions;

    /// <summary>
    /// Partitions
    /// </summary>
    public List<global::rDSN.Tron.ServicePartitionInfo> Partitions
    {
        get { return this.m_Partitions; }
        set { this.m_Partitions = value; }
    }

    new public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Partitions_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceInfoEx");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Partitions
            Partitions_meta.name = "Partitions";
            Partitions_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Partitions = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Partitions = "Partitions";
    }   // ~__internal

    // Constructor
    public ServiceInfoEx()
    {
        
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public override void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected new void Reset(string name, string qualifiedName)
    {
        base.Reset(name, qualifiedName);
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Partitions == null)
        {
            m_Partitions = new List<global::rDSN.Tron.ServicePartitionInfo>();
        }
        else
        {
            m_Partitions.Clear();
        }
    } // ResetImpl()

    public override IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceInfoEx cloned = new global::rDSN.Tron.ServiceInfoEx();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceInfoEx that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        base.CopyTo(that);
        // 1: vector<rDSN.Tron.ServicePartitionInfo> Partitions
        if (this.Partitions != null)
        {
            if (that.Partitions == null)
            {
                that.Partitions = new List<global::rDSN.Tron.ServicePartitionInfo>();
            }
            else
            {
                that.Partitions.Clear();
            }
            foreach (var iter1 in this.Partitions)
            {
                global::rDSN.Tron.ServicePartitionInfo tmpItem2 = default(global::rDSN.Tron.ServicePartitionInfo);
                tmpItem2 = (iter1 == null ? null : (global::rDSN.Tron.ServicePartitionInfo)iter1.Clone());
                that.Partitions.Add(tmpItem2);
            }
        }
        else
        {
            that.Partitions = null;
        }
    }    // ~CopyTo


    public override void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public override void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public override void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public override void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected new  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        
        base.ReadUntagged(reader);

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Partitions(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected new  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        
        base.Read(reader, out isPartialStruct);

        if (!isPartialStruct)
        {
            return;
        }        

        reader.ReadStructBegin(false);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Partitions:  // id=1
                    this.ReadField_impl_Partitions(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Partitions(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        global::Microsoft.Bond.ReadHelper.ValidateType(elemType1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
        if (this.m_Partitions.Capacity < count2)
        {
            this.m_Partitions.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            global::rDSN.Tron.ServicePartitionInfo element3 = new global::rDSN.Tron.ServicePartitionInfo();
             
            ReadHelper.ReadStruct(reader, element3, elemType1);
            this.m_Partitions.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Partitions


    override public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    override public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    new public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    override public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceInfoEx))
        {
            Write(writer, true);
        }
        else
        {
            base.Write(writer, type);
        }
    }

    new protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	    base.WriteInternal(writer, false);            

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, false);

        UInt32 count1 = ((UInt32)m_Partitions.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Partitions, Schema.Partitions_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    m_Partitions[idx2].Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Partitions, Schema.Partitions_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public override IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static new public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static new public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static new protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        structDef.base_def = global::rDSN.Tron.ServiceInfo.GetTypeDef(schema);
        

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Partitions";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element = global::rDSN.Tron.ServicePartitionInfo.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public override bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceInfoEx that = obj as ServiceInfoEx;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceInfoEx other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceInfoEx that)
    {
        bool equals = true;
        equals = equals && base.MemberwiseCompareQuick(that);
        equals = equals && ((this.Partitions == null) == (that.Partitions == null));
        equals = equals && ((this.Partitions == null) ? true : (this.Partitions.Count == that.Partitions.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceInfoEx that)
    {
        bool equals = true;
        equals = equals && base.MemberwiseCompareDeep(that);
        if (equals && this.Partitions != null && this.Partitions.Count != 0)
        {
            var enum_1_1 = this.Partitions.GetEnumerator();
            var enum_2_2 = that.Partitions.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current.MemberwiseCompare(enum_2_2.Current));
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public new string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Partitions, DumpList(this.Partitions), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServiceInfoEx

/// <summary>
/// AppServerInfo
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class AppServerInfo : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional string Host
    private String m_Host;

    // 2: Optional rDSN.Tron.NodeAddress Address
    private global::rDSN.Tron.NodeAddress m_Address;

    // 3: Optional map<string, rDSN.Tron.ServicePartitionInfo> Services
    private Dictionary<String, global::rDSN.Tron.ServicePartitionInfo> m_Services;

    // 4: Optional bool IsAlive
    private Boolean m_IsAlive;

    /// <summary>
    /// Host
    /// </summary>
    public String Host
    {
        get { return this.m_Host; }
        set { this.m_Host = value; }
    }

    /// <summary>
    /// Address
    /// </summary>
    public global::rDSN.Tron.NodeAddress Address
    {
        get { return this.m_Address; }
        set { this.m_Address = value; }
    }

    /// <summary>
    /// temp fix from map<uint64, ...> to ensure converting to json can work in C#
    /// </summary>
    public Dictionary<String, global::rDSN.Tron.ServicePartitionInfo> Services
    {
        get { return this.m_Services; }
        set { this.m_Services = value; }
    }

    /// <summary>
    /// IsAlive
    /// </summary>
    public Boolean IsAlive
    {
        get { return this.m_IsAlive; }
        set { this.m_IsAlive = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Host_meta = new Metadata();
        public static readonly Metadata Address_meta = new Metadata();
        public static readonly Metadata Services_meta = new Metadata();
        public static readonly Metadata IsAlive_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("AppServerInfo");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Host
            Host_meta.name = "Host";
            Host_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Address
            Address_meta.name = "Address";
            Address_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Services
            Services_meta.name = "Services";
            Services_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // IsAlive
            IsAlive_meta.name = "IsAlive";
            IsAlive_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            IsAlive_meta.default_value.uint_value = 0;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Host = 1;
        public const int Address = 2;
        public const int Services = 3;
        public const int IsAlive = 4;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Host = "Host";
        public const String s_Address = "Address";
        public const String s_Services = "Services";
        public const String s_IsAlive = "IsAlive";
    }   // ~__internal

    // Constructor
    public AppServerInfo()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Host = string.Empty;
        m_Address = new global::rDSN.Tron.NodeAddress();
        if (m_Services == null)
        {
            m_Services = new Dictionary<String, global::rDSN.Tron.ServicePartitionInfo>();
        }
        else
        {
            m_Services.Clear();
        }
        m_IsAlive = false;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.AppServerInfo cloned = new global::rDSN.Tron.AppServerInfo();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.AppServerInfo that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: string Host
        that.Host = this.Host;
        // 2: rDSN.Tron.NodeAddress Address
        that.Address = (this.Address == null ? null : (global::rDSN.Tron.NodeAddress)this.Address.Clone());
        // 3: map<string, rDSN.Tron.ServicePartitionInfo> Services
        if (this.Services != null)
        {
            if (that.Services == null)
            {
                that.Services = new Dictionary<String, global::rDSN.Tron.ServicePartitionInfo>();
            }
            else
            {
                that.Services.Clear();
            }
            foreach (var keyValPair1 in this.Services)
            {
                String key2 = default(String);
                global::rDSN.Tron.ServicePartitionInfo val3 = default(global::rDSN.Tron.ServicePartitionInfo);
                key2 = keyValPair1.Key;
                val3 = (keyValPair1.Value == null ? null : (global::rDSN.Tron.ServicePartitionInfo)keyValPair1.Value.Clone());
                that.Services[key2] = val3;
            }
        }
        else
        {
            that.Services = null;
        }
        // 4: bool IsAlive
        that.IsAlive = this.IsAlive;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Host = reader.ReadString();
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Address.Read(reader);
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Services(reader, global::Microsoft.Bond.BondDataType.BT_MAP);
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.IsAlive = reader.ReadBool();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Host:  // id=1
                    this.Host = global::Microsoft.Bond.ReadHelper.ReadString(reader, type);
                    break;
                case __ordinals.Address:  // id=2
                    global::Microsoft.Bond.ReadHelper.ValidateType(type, global::Microsoft.Bond.BondDataType.BT_STRUCT);
                    this.Address.Read(reader);
                    break;
                case __ordinals.Services:  // id=3
                    this.ReadField_impl_Services(reader, type);
                    break;
                case __ordinals.IsAlive:  // id=4
                    this.IsAlive = global::Microsoft.Bond.ReadHelper.ReadBool(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Services(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_MAP);
 
        
        BondDataType keyType1, valueType2;
    
        UInt32 count3;
    
        reader.ReadContainerBegin(out count3, out keyType1, out valueType2);
        global::Microsoft.Bond.ReadHelper.ValidateType(valueType2, global::Microsoft.Bond.BondDataType.BT_STRUCT);
    
        for (UInt32 i4 = 0; i4 < count3; i4++)
        {
            String key5 = default(String);
            global::rDSN.Tron.ServicePartitionInfo val6 = new global::rDSN.Tron.ServicePartitionInfo();
    
            // Read key
             
            key5 = global::Microsoft.Bond.ReadHelper.ReadString(reader, keyType1);
    
            // Read value
             
            ReadHelper.ReadStruct(reader, val6, valueType2);
            //
            this.m_Services[key5] = val6;
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Services


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(AppServerInfo))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        if (writeAllFields || (!Schema.Host_meta.default_value.Equals(m_Host)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Host, Schema.Host_meta);
                writer.WriteString(m_Host);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_STRING, __ordinals.Host, Schema.Host_meta);
        }

        writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRUCT, __ordinals.Address, Schema.Address_meta);
            m_Address.Write(writer, true);
        writer.WriteFieldEnd();
        UInt32 count1 = ((UInt32)m_Services.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_MAP, __ordinals.Services, Schema.Services_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRING, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            foreach (var iter2 in m_Services)
            {
                // Key
                    writer.WriteString(iter2.Key);
                // Value
                    iter2.Value.Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_MAP, __ordinals.Services, Schema.Services_meta);
        }

        if (writeAllFields || (!Schema.IsAlive_meta.default_value.Equals(m_IsAlive)))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_BOOL, __ordinals.IsAlive, Schema.IsAlive_meta);
                writer.WriteBool(m_IsAlive);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_BOOL, __ordinals.IsAlive, Schema.IsAlive_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Host";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_STRING;

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Address";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type = global::rDSN.Tron.NodeAddress.GetTypeDef(schema);

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 3;
        field.metadata.name="Services";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_MAP;
        field.type.key = new global::Microsoft.Bond.TypeDef();
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.key.id = global::Microsoft.Bond.BondDataType.BT_STRING;
        field.type.element = global::rDSN.Tron.ServicePartitionInfo.GetTypeDef(schema);

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 4;
        field.metadata.name="IsAlive";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.uint_value = false?1:0;
        field.type.id = global::Microsoft.Bond.BondDataType.BT_BOOL;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        AppServerInfo that = obj as AppServerInfo;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(AppServerInfo other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(AppServerInfo that)
    {
        bool equals = true;
        
        equals = equals && ((this.Host == null) == (that.Host == null));
        equals = equals && (this.Host == null ? true : (this.Host.Length == that.Host.Length));
        equals = equals && ((this.Services == null) == (that.Services == null));
        equals = equals && ((this.Services == null) ? true : (this.Services.Count == that.Services.Count));
        equals = equals && ((this.IsAlive == that.IsAlive));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(AppServerInfo that)
    {
        bool equals = true;
        
        equals = equals && (this.Host == null ? true : this.Host == that.Host);
        equals = equals && (this.Address == null ? true : this.Address.MemberwiseCompare(that.Address));
        if (equals && this.Services != null && this.Services.Count != 0)
        {
            foreach (var keyValPair1 in this.Services)
            {
                global::rDSN.Tron.ServicePartitionInfo val2 = default(global::rDSN.Tron.ServicePartitionInfo);
                equals = equals && that.Services.TryGetValue(keyValPair1.Key, out val2);
                if (equals)
                {
                        equals = equals && ((val2 == null) == (keyValPair1.Value == null));
                    equals = equals && (val2 == null ? true : val2.MemberwiseCompare(keyValPair1.Value));
                }
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Host, this.Host, separator);
        sb.AppendFormat(format, __internal.s_Address, this.Address, separator);
        sb.AppendFormat(format, __internal.s_Services, this.Services, separator);
        sb.AppendFormat(format, __internal.s_IsAlive, this.IsAlive, separator);
        
        return sb.ToString();
    } // ToString()

}; // class AppServerInfo

/// <summary>
/// ServicePartitionAction
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public enum ServicePartitionAction
{
                    
    PUT,
    REMOVE,
}; // enum ServicePartitionAction

} // namespace Tron
} // namespace rDSN
