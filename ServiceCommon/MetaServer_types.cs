/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Microsoft Corporation
 * 
 * -=- Robust Distributed System Nucleus (rDSN) -=- 
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Description:
 *     What is this file about?
 *
 * Revision history:
 *     Feb., 2016, @imzhenyu (Zhenyu Guo), done in Tron project and copied here
 *     xxxx-xx-xx, author, fix bug about xxx
 */
 




//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.retail.not
//     Template : Microsoft.Bond.Rules.dll#Rules_Bond_CSharp.tt
//     File     : MetaServer_types.cs
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::Microsoft.Bond;
using global::System;
using global::System.Collections;
using global::System.Collections.Generic;
using global::System.Text;

namespace rDSN
{
namespace Tron
{

/// <summary>
/// ServiceListResponse
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServiceListResponse : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional vector<rDSN.Tron.RpcResponse<rDSN.Tron.ServiceInfoEx>> Services
    private List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>> m_Services;

    /// <summary>
    /// Services
    /// </summary>
    public List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>> Services
    {
        get { return this.m_Services; }
        set { this.m_Services = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Services_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServiceListResponse");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Services
            Services_meta.name = "Services";
            Services_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Services = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Services = "Services";
    }   // ~__internal

    // Constructor
    public ServiceListResponse()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Services == null)
        {
            m_Services = new List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>>();
        }
        else
        {
            m_Services.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServiceListResponse cloned = new global::rDSN.Tron.ServiceListResponse();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServiceListResponse that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: vector<rDSN.Tron.RpcResponse<rDSN.Tron.ServiceInfoEx>> Services
        if (this.Services != null)
        {
            if (that.Services == null)
            {
                that.Services = new List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>>();
            }
            else
            {
                that.Services.Clear();
            }
            foreach (var iter1 in this.Services)
            {
                global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx> tmpItem2 = default(global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>);
                tmpItem2 = (iter1 == null ? null : (global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>)iter1.Clone());
                that.Services.Add(tmpItem2);
            }
        }
        else
        {
            that.Services = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Services(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Services:  // id=1
                    this.ReadField_impl_Services(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Services(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        global::Microsoft.Bond.ReadHelper.ValidateType(elemType1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
        if (this.m_Services.Capacity < count2)
        {
            this.m_Services.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx> element3 = new global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>();
             
            ReadHelper.ReadStruct(reader, element3, elemType1);
            this.m_Services.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Services


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServiceListResponse))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        UInt32 count1 = ((UInt32)m_Services.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Services, Schema.Services_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    m_Services[idx2].Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Services, Schema.Services_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Services";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element = global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServiceInfoEx>.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServiceListResponse that = obj as ServiceListResponse;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServiceListResponse other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServiceListResponse that)
    {
        bool equals = true;
        
        equals = equals && ((this.Services == null) == (that.Services == null));
        equals = equals && ((this.Services == null) ? true : (this.Services.Count == that.Services.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServiceListResponse that)
    {
        bool equals = true;
        
        if (equals && this.Services != null && this.Services.Count != 0)
        {
            var enum_1_1 = this.Services.GetEnumerator();
            var enum_2_2 = that.Services.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current.MemberwiseCompare(enum_2_2.Current));
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Services, DumpList(this.Services), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServiceListResponse

/// <summary>
/// ServerListRequest
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServerListRequest : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional vector<rDSN.Tron.NodeAddress> Nodes
    private List<global::rDSN.Tron.NodeAddress> m_Nodes;

    /// <summary>
    /// Nodes
    /// </summary>
    public List<global::rDSN.Tron.NodeAddress> Nodes
    {
        get { return this.m_Nodes; }
        set { this.m_Nodes = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Nodes_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServerListRequest");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Nodes
            Nodes_meta.name = "Nodes";
            Nodes_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Nodes = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Nodes = "Nodes";
    }   // ~__internal

    // Constructor
    public ServerListRequest()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Nodes == null)
        {
            m_Nodes = new List<global::rDSN.Tron.NodeAddress>();
        }
        else
        {
            m_Nodes.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServerListRequest cloned = new global::rDSN.Tron.ServerListRequest();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServerListRequest that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: vector<rDSN.Tron.NodeAddress> Nodes
        if (this.Nodes != null)
        {
            if (that.Nodes == null)
            {
                that.Nodes = new List<global::rDSN.Tron.NodeAddress>();
            }
            else
            {
                that.Nodes.Clear();
            }
            foreach (var iter1 in this.Nodes)
            {
                global::rDSN.Tron.NodeAddress tmpItem2 = default(global::rDSN.Tron.NodeAddress);
                tmpItem2 = (iter1 == null ? null : (global::rDSN.Tron.NodeAddress)iter1.Clone());
                that.Nodes.Add(tmpItem2);
            }
        }
        else
        {
            that.Nodes = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Nodes(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Nodes:  // id=1
                    this.ReadField_impl_Nodes(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Nodes(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        global::Microsoft.Bond.ReadHelper.ValidateType(elemType1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
        if (this.m_Nodes.Capacity < count2)
        {
            this.m_Nodes.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            global::rDSN.Tron.NodeAddress element3 = new global::rDSN.Tron.NodeAddress();
             
            ReadHelper.ReadStruct(reader, element3, elemType1);
            this.m_Nodes.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Nodes


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServerListRequest))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        UInt32 count1 = ((UInt32)m_Nodes.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Nodes, Schema.Nodes_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    m_Nodes[idx2].Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Nodes, Schema.Nodes_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Nodes";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element = global::rDSN.Tron.NodeAddress.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServerListRequest that = obj as ServerListRequest;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServerListRequest other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServerListRequest that)
    {
        bool equals = true;
        
        equals = equals && ((this.Nodes == null) == (that.Nodes == null));
        equals = equals && ((this.Nodes == null) ? true : (this.Nodes.Count == that.Nodes.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServerListRequest that)
    {
        bool equals = true;
        
        if (equals && this.Nodes != null && this.Nodes.Count != 0)
        {
            var enum_1_1 = this.Nodes.GetEnumerator();
            var enum_2_2 = that.Nodes.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current.MemberwiseCompare(enum_2_2.Current));
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Nodes, DumpList(this.Nodes), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServerListRequest

/// <summary>
/// ServerListResponse
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServerListResponse : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional vector<rDSN.Tron.RpcResponse<rDSN.Tron.AppServerInfo>> Servers
    private List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>> m_Servers;

    /// <summary>
    /// Servers
    /// </summary>
    public List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>> Servers
    {
        get { return this.m_Servers; }
        set { this.m_Servers = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Servers_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServerListResponse");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Servers
            Servers_meta.name = "Servers";
            Servers_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Servers = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Servers = "Servers";
    }   // ~__internal

    // Constructor
    public ServerListResponse()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Servers == null)
        {
            m_Servers = new List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>>();
        }
        else
        {
            m_Servers.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServerListResponse cloned = new global::rDSN.Tron.ServerListResponse();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServerListResponse that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: vector<rDSN.Tron.RpcResponse<rDSN.Tron.AppServerInfo>> Servers
        if (this.Servers != null)
        {
            if (that.Servers == null)
            {
                that.Servers = new List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>>();
            }
            else
            {
                that.Servers.Clear();
            }
            foreach (var iter1 in this.Servers)
            {
                global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo> tmpItem2 = default(global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>);
                tmpItem2 = (iter1 == null ? null : (global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>)iter1.Clone());
                that.Servers.Add(tmpItem2);
            }
        }
        else
        {
            that.Servers = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Servers(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Servers:  // id=1
                    this.ReadField_impl_Servers(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Servers(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        global::Microsoft.Bond.ReadHelper.ValidateType(elemType1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
        if (this.m_Servers.Capacity < count2)
        {
            this.m_Servers.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo> element3 = new global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>();
             
            ReadHelper.ReadStruct(reader, element3, elemType1);
            this.m_Servers.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Servers


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServerListResponse))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        UInt32 count1 = ((UInt32)m_Servers.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Servers, Schema.Servers_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    m_Servers[idx2].Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Servers, Schema.Servers_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Servers";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element = global::rDSN.Tron.RpcResponse<global::rDSN.Tron.AppServerInfo>.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServerListResponse that = obj as ServerListResponse;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServerListResponse other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServerListResponse that)
    {
        bool equals = true;
        
        equals = equals && ((this.Servers == null) == (that.Servers == null));
        equals = equals && ((this.Servers == null) ? true : (this.Servers.Count == that.Servers.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServerListResponse that)
    {
        bool equals = true;
        
        if (equals && this.Servers != null && this.Servers.Count != 0)
        {
            var enum_1_1 = this.Servers.GetEnumerator();
            var enum_2_2 = that.Servers.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current.MemberwiseCompare(enum_2_2.Current));
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Servers, DumpList(this.Servers), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServerListResponse

/// <summary>
/// ServerList
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServerList : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional vector<rDSN.Tron.AppServerInfo> Servers
    private List<global::rDSN.Tron.AppServerInfo> m_Servers;

    /// <summary>
    /// Servers
    /// </summary>
    public List<global::rDSN.Tron.AppServerInfo> Servers
    {
        get { return this.m_Servers; }
        set { this.m_Servers = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Servers_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServerList");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Servers
            Servers_meta.name = "Servers";
            Servers_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Servers = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Servers = "Servers";
    }   // ~__internal

    // Constructor
    public ServerList()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Servers == null)
        {
            m_Servers = new List<global::rDSN.Tron.AppServerInfo>();
        }
        else
        {
            m_Servers.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServerList cloned = new global::rDSN.Tron.ServerList();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServerList that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: vector<rDSN.Tron.AppServerInfo> Servers
        if (this.Servers != null)
        {
            if (that.Servers == null)
            {
                that.Servers = new List<global::rDSN.Tron.AppServerInfo>();
            }
            else
            {
                that.Servers.Clear();
            }
            foreach (var iter1 in this.Servers)
            {
                global::rDSN.Tron.AppServerInfo tmpItem2 = default(global::rDSN.Tron.AppServerInfo);
                tmpItem2 = (iter1 == null ? null : (global::rDSN.Tron.AppServerInfo)iter1.Clone());
                that.Servers.Add(tmpItem2);
            }
        }
        else
        {
            that.Servers = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Servers(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Servers:  // id=1
                    this.ReadField_impl_Servers(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Servers(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        global::Microsoft.Bond.ReadHelper.ValidateType(elemType1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
        if (this.m_Servers.Capacity < count2)
        {
            this.m_Servers.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            global::rDSN.Tron.AppServerInfo element3 = new global::rDSN.Tron.AppServerInfo();
             
            ReadHelper.ReadStruct(reader, element3, elemType1);
            this.m_Servers.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Servers


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServerList))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        UInt32 count1 = ((UInt32)m_Servers.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Servers, Schema.Servers_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    m_Servers[idx2].Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Servers, Schema.Servers_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Servers";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element = global::rDSN.Tron.AppServerInfo.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServerList that = obj as ServerList;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServerList other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServerList that)
    {
        bool equals = true;
        
        equals = equals && ((this.Servers == null) == (that.Servers == null));
        equals = equals && ((this.Servers == null) ? true : (this.Servers.Count == that.Servers.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServerList that)
    {
        bool equals = true;
        
        if (equals && this.Servers != null && this.Servers.Count != 0)
        {
            var enum_1_1 = this.Servers.GetEnumerator();
            var enum_2_2 = that.Servers.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current.MemberwiseCompare(enum_2_2.Current));
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Servers, DumpList(this.Servers), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServerList

/// <summary>
/// ServerListResponse2
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServerListResponse2 : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional vector<rDSN.Tron.RpcResponse<rDSN.Tron.ServerList>> Servers
    private List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>> m_Servers;

    /// <summary>
    /// Servers
    /// </summary>
    public List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>> Servers
    {
        get { return this.m_Servers; }
        set { this.m_Servers = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Servers_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServerListResponse2");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Servers
            Servers_meta.name = "Servers";
            Servers_meta.modifier = global::Microsoft.Bond.Modifier.Optional;
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Servers = 1;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Servers = "Servers";
    }   // ~__internal

    // Constructor
    public ServerListResponse2()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        if (m_Servers == null)
        {
            m_Servers = new List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>>();
        }
        else
        {
            m_Servers.Clear();
        }
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServerListResponse2 cloned = new global::rDSN.Tron.ServerListResponse2();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServerListResponse2 that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: vector<rDSN.Tron.RpcResponse<rDSN.Tron.ServerList>> Servers
        if (this.Servers != null)
        {
            if (that.Servers == null)
            {
                that.Servers = new List<global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>>();
            }
            else
            {
                that.Servers.Clear();
            }
            foreach (var iter1 in this.Servers)
            {
                global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList> tmpItem2 = default(global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>);
                tmpItem2 = (iter1 == null ? null : (global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>)iter1.Clone());
                that.Servers.Add(tmpItem2);
            }
        }
        else
        {
            that.Servers = null;
        }
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.ReadField_impl_Servers(reader, global::Microsoft.Bond.BondDataType.BT_LIST);
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Servers:  // id=1
                    this.ReadField_impl_Servers(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    private void ReadField_impl_Servers(global::Microsoft.Bond.IProtocolReader reader, global::Microsoft.Bond.BondDataType typeInPayload)
    {
        global::Microsoft.Bond.ReadHelper.ValidateType(typeInPayload, global::Microsoft.Bond.BondDataType.BT_LIST);
 
        BondDataType elemType1;
        UInt32 count2;
    
        reader.ReadContainerBegin(out count2, out elemType1);
        global::Microsoft.Bond.ReadHelper.ValidateType(elemType1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
        if (this.m_Servers.Capacity < count2)
        {
            this.m_Servers.Capacity = (int)count2;
        }
    
        for (UInt32 i4 = 0; i4 < count2; i4++)
        {
            global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList> element3 = new global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>();
             
            ReadHelper.ReadStruct(reader, element3, elemType1);
            this.m_Servers.Add(element3);
        }
    
        reader.ReadContainerEnd();
    } // ReadField_impl_Servers


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServerListResponse2))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        UInt32 count1 = ((UInt32)m_Servers.Count);
        if (writeAllFields || count1 != 0)
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Servers, Schema.Servers_meta);
                writer.WriteContainerBegin(count1, global::Microsoft.Bond.BondDataType.BT_STRUCT);
            for (int idx2 = 0; idx2 < count1; idx2++)
            {
                    m_Servers[idx2].Write(writer, true);
            }
            writer.WriteContainerEnd();
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_LIST, __ordinals.Servers, Schema.Servers_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Servers";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type.id = global::Microsoft.Bond.BondDataType.BT_LIST;
        field.type.element = new global::Microsoft.Bond.TypeDef();
        field.type.element = global::rDSN.Tron.RpcResponse<global::rDSN.Tron.ServerList>.GetTypeDef(schema);

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServerListResponse2 that = obj as ServerListResponse2;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServerListResponse2 other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServerListResponse2 that)
    {
        bool equals = true;
        
        equals = equals && ((this.Servers == null) == (that.Servers == null));
        equals = equals && ((this.Servers == null) ? true : (this.Servers.Count == that.Servers.Count));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServerListResponse2 that)
    {
        bool equals = true;
        
        if (equals && this.Servers != null && this.Servers.Count != 0)
        {
            var enum_1_1 = this.Servers.GetEnumerator();
            var enum_2_2 = that.Servers.GetEnumerator();
            while (enum_1_1.MoveNext() && enum_2_2.MoveNext())
            {
                    equals = equals && ((enum_1_1.Current == null) == (enum_2_2.Current == null));
                equals = equals && (enum_1_1.Current == null ? true : enum_1_1.Current.MemberwiseCompare(enum_2_2.Current));
                if (!equals)
                {
                    break;
                }
            }
        }
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Servers, DumpList(this.Servers), separator);
        
        return sb.ToString();
    } // ToString()

    private string DumpList<T_DumpList_Type>(IEnumerable<T_DumpList_Type> list)
    {
        if (list == null)
        {
            return "-";
        }
        
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        
        bool isFirst = true;
        foreach (var item in list)
        {
            if (!isFirst)
            {
                sb.Append(';');
            }
            
            sb.Append(item.ToString());
            isFirst = false;
        }
        
        return sb.ToString();
    }
}; // class ServerListResponse2

/// <summary>
/// ServicePlaceRequest
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("bondc.exe", null)]
public partial class ServicePlaceRequest : IBondSerializable, IGenericSerializer
{
    //
    // Fields
    //

    // 1: Optional rDSN.Tron.ServicePartitionInfo Partition
    private global::rDSN.Tron.ServicePartitionInfo m_Partition;

    // 2: Optional rDSN.Tron.ServicePartitionAction Act
    private global::rDSN.Tron.ServicePartitionAction m_Act;

    /// <summary>
    /// Partition
    /// </summary>
    public global::rDSN.Tron.ServicePartitionInfo Partition
    {
        get { return this.m_Partition; }
        set { this.m_Partition = value; }
    }

    /// <summary>
    /// Act
    /// </summary>
    public global::rDSN.Tron.ServicePartitionAction Act
    {
        get { return this.m_Act; }
        set { this.m_Act = value; }
    }

    public static string GetFullyQualifiedName()
    {
        return __internal.sc_structQualifiedName;
    }

    /// <summary>
    /// Meta schema.
    /// </summary>
    private static class Schema
    {
        public static readonly Metadata meta = new Metadata();
        public static readonly Metadata Partition_meta = new Metadata();
        public static readonly Metadata Act_meta = new Metadata();

        static Schema()
        {
            StringBuilder runtimeName = new StringBuilder();
            runtimeName.Append("ServicePlaceRequest");
 
            meta.name = runtimeName.ToString();
            meta.qualified_name = "rDSN.Tron." + meta.name;


            // Partition
            Partition_meta.name = "Partition";
            Partition_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            // Act
            Act_meta.name = "Act";
            Act_meta.modifier = global::Microsoft.Bond.Modifier.Optional;

            Act_meta.default_value.int_value = Convert.ToInt64(global::rDSN.Tron.ServicePartitionAction.PUT);
        }   // ~static Schema()

    }   // ~Schema


    private static class __ordinals
    {
        public const int Partition = 1;
        public const int Act = 2;
    }   // ~__ordinals


    private static class __internal
    {

        public static readonly String sc_structName = Schema.meta.name;
        public static readonly String sc_structQualifiedName = Schema.meta.qualified_name;

        public const String s_Partition = "Partition";
        public const String s_Act = "Act";
    }   // ~__internal

    // Constructor
    public ServicePlaceRequest()
    {
        Reset();
    }

    /// <summary>
    /// Reset instance and re-initialize the members.
    /// </summary>
    public virtual void Reset()
    {
        Reset(__internal.sc_structName, __internal.sc_structQualifiedName);
    }

    protected  void Reset(string name, string qualifiedName)
    {
        
        ResetImpl(name, qualifiedName);
    }

    private void ResetImpl(string name, string qualifiedName)
    {
        m_Partition = new global::rDSN.Tron.ServicePartitionInfo();
        m_Act = global::rDSN.Tron.ServicePartitionAction.PUT;
    } // ResetImpl()

    public virtual IBondSerializable Clone()
    {
        global::rDSN.Tron.ServicePlaceRequest cloned = new global::rDSN.Tron.ServicePlaceRequest();
        CopyTo(cloned);
        return cloned;
    }

    public void CopyTo(global::rDSN.Tron.ServicePlaceRequest that)
    {
        if (that == null)
        {
            throw new  ArgumentNullException("that");
        }
        
        // 1: rDSN.Tron.ServicePartitionInfo Partition
        that.Partition = (this.Partition == null ? null : (global::rDSN.Tron.ServicePartitionInfo)this.Partition.Clone());
        // 2: rDSN.Tron.ServicePartitionAction Act
        that.Act = this.Act;
    }    // ~CopyTo


    public virtual void Unmarshal(System.IO.Stream input)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, this);
    }

    public virtual void Unmarshal(System.IO.Stream input, IBondSerializable schema)
    {
        global::Microsoft.Bond.Marshaler.Unmarshal(input, schema as SchemaDef, this);
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader)
    {
        if (!reader.HasCapability(global::Microsoft.Bond.Protocol.Tagged))
        {
            ReadUntagged(reader);
        }
        else
        {
            bool isPartialStruct;

            if (reader.HasCapability((global::Microsoft.Bond.Protocol)global::Microsoft.Bond.ProtocolInternal.CloneableBonded))
            {
                reader = reader.Clone();
            }
            
            Read(reader, out isPartialStruct);
            
            if (isPartialStruct)
            {
                global::Microsoft.Bond.ReadHelper.SkipPartialStruct(reader);
            }
        }
    }

    public virtual void Read(global::Microsoft.Bond.IProtocolReader reader, IBondSerializable schema)
    {
        Read(ProtocolHelper.CreateReader(reader, schema));
    }

    protected  void ReadUntagged(global::Microsoft.Bond.IProtocolReader reader)
    {
        bool canOmitFields = reader.HasCapability(global::Microsoft.Bond.Protocol.CanOmitFields);
        Reset();
        

        reader.ReadStructBegin();

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Partition.Read(reader);
        }

        if (!canOmitFields || !reader.ReadFieldOmitted())
        {
            this.Act = (global::rDSN.Tron.ServicePartitionAction)reader.ReadInt32();
        }
        reader.ReadStructEnd();
    }   // ~ReadUntagged()


    protected  void Read(global::Microsoft.Bond.IProtocolReader reader, out bool isPartialStruct)
    {
        Reset();

        reader.ReadStructBegin(true);
        
        while (true)
        {
            BondDataType type = BondDataType.BT_STOP;
            UInt16 id = UInt16.MaxValue;

            reader.ReadFieldBegin(out type, out id);

            if (type == BondDataType.BT_STOP || type == BondDataType.BT_STOP_BASE)
            {
                isPartialStruct = (type == BondDataType.BT_STOP_BASE);
                break;
            }

            switch (id)
            {
                case __ordinals.Partition:  // id=1
                    global::Microsoft.Bond.ReadHelper.ValidateType(type, global::Microsoft.Bond.BondDataType.BT_STRUCT);
                    this.Partition.Read(reader);
                    break;
                case __ordinals.Act:  // id=2
                    this.Act = (global::rDSN.Tron.ServicePartitionAction)global::Microsoft.Bond.ReadHelper.ReadInt32(reader, type);
                    break;
                default:
                    reader.Skip(type);
                    break;
            } // ~switch

            reader.ReadFieldEnd();

        } // ~while

        reader.ReadStructEnd();

    }   // ~Read()


    virtual public void Marshal(IProtocolWriter writer)
    {
        global::Microsoft.Bond.Marshaler.Marshal(this, writer);
    }

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer)
    {
        Write(writer, true);
    }

    public void Write(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
        global::Microsoft.Bond.IProtocolWriter pass0; 
        
        if (isTopLevel && (pass0 = writer.GetPass0Writer()) != null)
        {
            WriteInternal(pass0, isTopLevel);
            WriteInternal(writer, isTopLevel);
            writer.EndDoublePass();
        }
        else
        {
            WriteInternal(writer, isTopLevel);
        }
    }   // ~Write()

    virtual public void Write(global::Microsoft.Bond.IProtocolWriter writer, System.Type type)
    {
        if (type == typeof(ServicePlaceRequest))
        {
            Write(writer, true);
        }
    }

    protected void WriteInternal(global::Microsoft.Bond.IProtocolWriter writer, bool isTopLevel)
    {
	                

        bool writeAllFields = !writer.MayOmitFields;

        writer.WriteStructBegin(Schema.meta, !isTopLevel, true);

        writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_STRUCT, __ordinals.Partition, Schema.Partition_meta);
            m_Partition.Write(writer, true);
        writer.WriteFieldEnd();
        if (writeAllFields || (!Schema.Act_meta.default_value.Equals(Convert.ToInt32(m_Act))))
        {
            writer.WriteFieldBegin(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Act, Schema.Act_meta);
                writer.WriteInt32((Int32)m_Act);
            writer.WriteFieldEnd();
        }
        else
        {
            writer.WriteFieldOmitted(global::Microsoft.Bond.BondDataType.BT_INT32, __ordinals.Act, Schema.Act_meta);
        }

        writer.WriteStructEnd(!isTopLevel);
    }   // ~Write()

    private static volatile global::Microsoft.Bond.SchemaDef __schema;

    public virtual IBondSerializable GetSchema()
    {
        return GetRuntimeSchema();
    }

    static public global::Microsoft.Bond.SchemaDef GetRuntimeSchema()
    {
        if (__schema == null)
        {
            var schema = new global::Microsoft.Bond.SchemaDef();
            schema.root = GetTypeDef(schema);
            __schema = schema;
        }
        return __schema;
    }

    static public global::Microsoft.Bond.TypeDef GetTypeDef(global::Microsoft.Bond.SchemaDef schema)
    {
        global::Microsoft.Bond.TypeDef type = new global::Microsoft.Bond.TypeDef();
        type.id = global::Microsoft.Bond.BondDataType.BT_STRUCT;
        type.struct_def = GetStructDef(schema);
        return type;
    }

    static protected UInt16 GetStructDef(global::Microsoft.Bond.SchemaDef schema)
    {
        UInt16 pos;

        for(pos = 0; pos < schema.structs.Count; pos++)
        {
            if (schema.structs[pos].metadata.qualified_name == __internal.sc_structQualifiedName)
            {
                return pos;
            }
        }
        // pos == schema.structs.Count

        global::Microsoft.Bond.StructDef structDef = new global::Microsoft.Bond.StructDef();
        structDef.metadata.name = __internal.sc_structName;
        structDef.metadata.qualified_name = __internal.sc_structQualifiedName;
        schema.structs.Add(structDef);

        global::Microsoft.Bond.FieldDef field;


        field = new global::Microsoft.Bond.FieldDef();
        field.id = 1;
        field.metadata.name="Partition";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.type = global::rDSN.Tron.ServicePartitionInfo.GetTypeDef(schema);

        structDef.fields.Add(field);

        field = new global::Microsoft.Bond.FieldDef();
        field.id = 2;
        field.metadata.name="Act";
        field.metadata.modifier = global::Microsoft.Bond.Modifier.Optional;
        field.metadata.default_value.nothing = false;

        field.metadata.default_value.int_value = Convert.ToInt64(global::rDSN.Tron.ServicePartitionAction.PUT);
        field.type.id = global::Microsoft.Bond.BondDataType.BT_INT32;

        structDef.fields.Add(field);

        return pos;
    }
 
    public virtual bool MemberwiseCompare(object obj)
    {
        if (obj == null)
        {
            return false;
        }
        
        ServicePlaceRequest that = obj as ServicePlaceRequest;
        if (that == null)
        {
            return false;
        }
        
        return this.MemberwiseCompare(that);
    }
    
    public bool MemberwiseCompare(ServicePlaceRequest other)
    {
        if (!MemberwiseCompareQuick(other))
        {
            return false;
        }
        
        return MemberwiseCompareDeep(other);
    }
    

    protected bool MemberwiseCompareQuick(ServicePlaceRequest that)
    {
        bool equals = true;
        
        equals = equals && ((this.Act == that.Act));
        return equals;
    }    // ~MemberwiseCompareQuick
    
    protected bool MemberwiseCompareDeep(ServicePlaceRequest that)
    {
        bool equals = true;
        
        equals = equals && (this.Partition == null ? true : this.Partition.MemberwiseCompare(that.Partition));
        return equals;
    }    // ~MemberwiseCompareDeep
    
    public override string ToString()
    {
        return ToString(false, '\n');
    }

    public  string ToString(bool valuesOnly, char separator)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
   
        if (!valuesOnly)
        {
            sb.AppendFormat("{0}{1}{2}{1}", base.ToString(), separator, __internal.sc_structName);
        }
        
        string format = valuesOnly ? "{1}{2}" : "{0} = {1}{2}";
        sb.AppendFormat(format, __internal.s_Partition, this.Partition, separator);
        sb.AppendFormat(format, __internal.s_Act, this.Act, separator);
        
        return sb.ToString();
    } // ToString()

}; // class ServicePlaceRequest
} // namespace Tron
} // namespace rDSN
